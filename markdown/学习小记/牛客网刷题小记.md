## 牛客网刷题小记

### MySQL
1.查询语句执行顺序
（8）Select
（9）distinct 字段名1,字段名2，
（6）[fun(字段名)]  
（1）from 表1
（3）<join类型>join 表2 
（2）on <join条件> 
（4）where <where条件> 
（5）group by <字段> 
（7）having <having条件> 
（10）order by <排序字段> 
（11）limit <起始偏移量,行数>
2.使用聚合函数，则判断条件使用having
where---过滤指定的行
having--过滤分组，与group by连用
返回订单数量总和不小于100:having sum(quantity)>= 100
3.返回同一表中的字段及字段别名，group、order同时使用
返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines对结果进行升序排序。
SELECT 
    order_num,
    COUNT(order_num) order_lines
FROM
    OrderItems
GROUP BY
    order_num
ORDER BY
    order_lines;
4.
可以使用ORDER BY，GROUP BY和HAVING子句中的列别名来引用该列。
不能在WHERE子句中使用列别名。原因是当MySQL评估求值WHERE子句时，SELECT子句中指定的列的值可能尚未确定。

5.MYSQL中何时使用group by
1）当聚合列和非聚合列出现在一起时必须使用group by,如:
#emp为员工表,deptno为部门编号字段,sal为工资字段
SELECT deptno,MAX(sal),AVG(sal) FROM emp
GROUP BY deptno #按照部门分组

当使用group by时,应使用非聚合列为分组依据.

2）什么是聚合列
聚合列是指根据需求算出结果的列,
常使用的聚合列函数有
count(求个数),
sum(求合),
max(求最大值),
min(求最小值),
avg(求平均数)

#emp为员工表,sal为工资字段

#求emp字段一共有几条数据
select count(*) from emp
#求员工工资总和
select sum(sal) from emp
#求员工最高工资
select max(sal) from emp
#求员工最低工资
select min(sal) from emp
#求员工平均 工资
select avg(sal) from emp

3）having条件查询
当使用group by进行分组时,想要使用条件查询,必须使用having,而不是where

#查询平均工资小于8000的部门
#emp为员工表,deptno为部门编号字段,sal为工资字段
select deptno, AVG(sal) from emp
group by deptno #按部门分组
having AVG(sal)<8000 #查询条件,类似where,但是group by中只能使用having
将两个 SELECT 语句结合起来（一）#
发表于 04-28 17:08
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;

6.
union--连接表，对行操作。
union--将两个表做行拼接，同时自动删除重复的行。
union all---将两个表做行拼接，保留重复的行
【问题】
    将两个 SELECT 语句结合起来，以便从 OrderItems表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。
    
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;
select *  from OrderItems where quantity=100
union
select * from OrderItems where prod_id like "BNBG%"
order by prod_id;

使用union组合查询时，只能使用一条order by字句，他必须位于最后一条select语句之后，因为对于结果集不存在对于一部分数据进行排序，而另一部分用另一种排序规则的情况。 

### java
1.HttpServlet容器响应Web客户请求流程如下：
1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

2.try块中放置可能引发异常的代码 故不可被省略
Jdk1.7中新增了多个catch块的功能，用以捕获多异常， 捕获顺序为先小后大
finally块用作回收无法被JVM回收的物理资源 例如数据库链接 网络链接等 Jdk1.7中虽增强了try()的功能，使得其中的代码在程序执行完毕后自动关闭代码 相当与隐含finally块
catch块用作捕获异常
总结
异常处理语法结构中只有try块是必须的，但不能只有try块，1.7中的增强try除外 因为其中的try()已经隐含了finally了 
通常一个类实现序列化方式是实现序列化接口 Serializable

3.
序列化的作用：把数据长久的保存在磁盘中，磁盘和内存是不同的，内存一般在程序运行时占用，数据保存周期短，随程序结束而结束，磁盘可以长久保存数据

transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，就这个作用------在已序列化的类中使变量不序列化

4.

特殊变量super，提供了对父类的访问。

可以使用super访问父类被子类隐藏的变量或覆盖的方法。

每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

构造是不能被继承的。

5.规范
1、项目名全部小写.
2、包名全部小写.
3、类名首字母大写,其余组成词首字母依次大写.
4、变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写.
5、常量名全部大写.
6、所有命名规则必须遵循以下规则 :

名称只能由字母、数字、下划线、$符号组成.
不能以数字开头.
名称不能使用Java中的关键字.
坚决不允许出现中文及拼音命名.

5.public,protected,private,default详解

![image-20220908095551242](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220908095551242.png)

public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不
　　　　　仅可以跨类访问，而且允许跨包（package）访问。
[private](https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020): Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以
　　　　　及方法只能被该类的对象访问，其[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)不能访问，更不能允许跨包访问。
protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、
　　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。
default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访
　　　　　问。



6.Java数据库连接库JDBC用到哪种设计模式?

**JDBC使用的是桥接模式**

**定义:将抽象部分与它的实现部分分离,使它们都可以独立的变化**

**意图:将抽象与实现解耦**



7.

在Java中数据域和方法都必须属于某一个对象。不能单独存在，没有C++中的全局变量和方法一说。对象必须属于某一个类。**

对象中可以什么也没有**

数据域可以是基本数据类型，也可以是引用类型。**

8.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）

```
this(x)
```

9.关于cookie和session

  程序一般都是在用户做log off的时候发个指令去删除session，然而浏览器从来不会主动在关闭之前通知服务器它将要被关闭，因此服务器根本不会有机会知道浏览器已经关闭。服务器会一直保留这个会话对象直到它处于非活动状态超过设定的间隔为止。 
   大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接到服务器时也就无法找到原来的session。 如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求报头，把原来的session id发送到服务器，则再次打开浏览器仍然能够找到原来的session。 
   恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为session设置了一个失效时间，当距离客户上一次使用session的时间超过了这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 
   **由此我们可以得出如下结论：** 
   关闭浏览器，只会是浏览器端内存里的session cookie消失，但不会使保存在服务器端的session对象消失，同样也不会使已经保存到硬盘上的持久化cookie消失。



10.整数相除之后还是整数，会丢失掉小数部分的数值。

11.HashMap底层是数组+链表+红黑树（JDK1.8）来实现的，根据key的hash值查找对应的位桶。

1.当前索引数组为空，则将键值对以链表形式插入。

2.当前索引数组已经存在，则判断当前链表是红黑树还时链表，然后插入。如果是链表插入到最后一个，判断长度是否大于8，大于8将链表转成红黑树。

所以应该是**拉链法**解决冲突。

12.jvm

![image-20220910082223873](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082223873.png)



大多数 JVM    将内存区域划分为 **Method    Area（Non-Heap）（方法区）** ,**Heap（堆）** , **Program    Counter Register（程序计数器）** ,  **VM Stack（虚拟机栈，也有翻译成JAVA    方法栈的）,Native Method    Stack** （ **本地方法栈** ），其中**Method Area** 和     ***\*Heap\**** 是线程共享的     ***\*，VM \*\*Stack，Native Method Stack 和\*\*Program          Counter Register\*\*\*\*\****       是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 

  首先我们熟悉一下一个一般性的  Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class  为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM  通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 

​    概括地说来，JVM初始运行的时候都会分配好 **Method  Area（方法区）** 和**Heap（堆）** ，而JVM    每遇到一个线程，就为其分配一个 **Program Counter    Register（程序计数器）** ,  **VM Stack（虚拟机栈）和Native Method  Stack （本地方法栈），** 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。

即，方法区用于存储JVM加载的类信息以及类相关的东西，比如类变量、常量等，是线程隔离的，但是编译器编译后的代码等数据，是线程共享的

![image-20220910082609831](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082609831.png)

13.

java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？

```
1 4 8 2 4 8 1
```

14.

成员变量与局部变量的区别 1、在类中的位置不同 成员变量：在类中方法外面 局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中） 2、在内存中的位置不同，可以看看Java程序内存的简单分析 成员变量：在堆中（方法区中的静态区） 局部变量：在栈中 3、生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失 4、初始值 成员变量：有默认初始值 局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized）

15.Java 中堆和栈有什么区别？

  JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

        栈：在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
    
        堆：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。
