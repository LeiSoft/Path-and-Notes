# 牛客网刷题小记

## MySQL
### 1.查询语句执行顺序

（8）Select
（9）distinct 字段名1,字段名2，
（6）[fun(字段名)]  
（1）from 表1
（3）<join类型>join 表2 
（2）on <join条件> 
（4）where <where条件> 
（5）group by <字段> 
（7）having <having条件> 
（10）order by <排序字段> 
（11）limit <起始偏移量,行数>

### 2.使用聚合函数，则判断条件使用having

where---过滤指定的行
having--过滤分组，与group by连用
返回订单数量总和不小于100:having sum(quantity)>= 100

### 3.返回同一表中的字段及字段别名，group、order同时使用

返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines对结果进行升序排序。
SELECT 
    order_num,
    COUNT(order_num) order_lines
FROM
    OrderItems
GROUP BY
    order_num
ORDER BY
    order_lines;

### 4.

可以使用ORDER BY，GROUP BY和HAVING子句中的列别名来引用该列。
不能在WHERE子句中使用列别名。原因是当MySQL评估求值WHERE子句时，SELECT子句中指定的列的值可能尚未确定。

### 5.MYSQL中何时使用group by

1）当聚合列和非聚合列出现在一起时必须使用group by,如:
#emp为员工表,deptno为部门编号字段,sal为工资字段
SELECT deptno,MAX(sal),AVG(sal) FROM emp
GROUP BY deptno #按照部门分组

当使用group by时,应使用非聚合列为分组依据.

2）什么是聚合列
聚合列是指根据需求算出结果的列,
常使用的聚合列函数有
count(求个数),
sum(求合),
max(求最大值),
min(求最小值),
avg(求平均数)

#emp为员工表,sal为工资字段

#求emp字段一共有几条数据
select count(*) from emp
#求员工工资总和
select sum(sal) from emp
#求员工最高工资
select max(sal) from emp
#求员工最低工资
select min(sal) from emp
#求员工平均 工资
select avg(sal) from emp

3）having条件查询
当使用group by进行分组时,想要使用条件查询,必须使用having,而不是where

#查询平均工资小于8000的部门
#emp为员工表,deptno为部门编号字段,sal为工资字段
select deptno, AVG(sal) from emp
group by deptno #按部门分组
having AVG(sal)<8000 #查询条件,类似where,但是group by中只能使用having
将两个 SELECT 语句结合起来（一）#
发表于 04-28 17:08
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;

### 6.union

union--连接表，对行操作。
union--将两个表做行拼接，同时自动删除重复的行。
union all---将两个表做行拼接，保留重复的行
【问题】
    将两个 SELECT 语句结合起来，以便从 OrderItems表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。
    
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;
select *  from OrderItems where quantity=100
union
select * from OrderItems where prod_id like "BNBG%"
order by prod_id;

使用union组合查询时，只能使用一条order by字句，他必须位于最后一条select语句之后，因为对于结果集不存在对于一部分数据进行排序，而另一部分用另一种排序规则的情况。 

## java
### 1.HttpServlet容器响应Web客户请求流程如下：

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

### 2.try块中放置可能引发异常的代码 故不可被省略

Jdk1.7中新增了多个catch块的功能，用以捕获多异常， 捕获顺序为先小后大
finally块用作回收无法被JVM回收的物理资源 例如数据库链接 网络链接等 Jdk1.7中虽增强了try()的功能，使得其中的代码在程序执行完毕后自动关闭代码 相当与隐含finally块
catch块用作捕获异常
总结
异常处理语法结构中只有try块是必须的，但不能只有try块，1.7中的增强try除外 因为其中的try()已经隐含了finally了 
通常一个类实现序列化方式是实现序列化接口 Serializable

### 3.序列化

序列化的作用：把数据长久的保存在磁盘中，磁盘和内存是不同的，内存一般在程序运行时占用，数据保存周期短，随程序结束而结束，磁盘可以长久保存数据

transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，就这个作用------在已序列化的类中使变量不序列化

### 4.super

特殊变量super，提供了对父类的访问。

可以使用super访问父类被子类隐藏的变量或覆盖的方法。

每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

构造是不能被继承的。

### 5.规范

1、项目名全部小写.
2、包名全部小写.
3、类名首字母大写,其余组成词首字母依次大写.
4、变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写.
5、常量名全部大写.
6、所有命名规则必须遵循以下规则 :

名称只能由字母、数字、下划线、$符号组成.
不能以数字开头.
名称不能使用Java中的关键字.
坚决不允许出现中文及拼音命名.

### 5.public,protected,private,default详解

![image-20220908095551242](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220908095551242.png)

public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不
　　　　　仅可以跨类访问，而且允许跨包（package）访问。
[private](https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020): Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以
　　　　　及方法只能被该类的对象访问，其[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)不能访问，更不能允许跨包访问。
protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、
　　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。
default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访
　　　　　问。



### 6.Java数据库连接库JDBC用到哪种设计模式?

**JDBC使用的是桥接模式**

**定义:将抽象部分与它的实现部分分离,使它们都可以独立的变化**

**意图:将抽象与实现解耦**



### 7.

在Java中数据域和方法都必须属于某一个对象。不能单独存在，没有C++中的全局变量和方法一说。对象必须属于某一个类。**

对象中可以什么也没有**

数据域可以是基本数据类型，也可以是引用类型。**

### 8.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）

```
this(x)
```

### 9.关于cookie和session

  程序一般都是在用户做log off的时候发个指令去删除session，然而浏览器从来不会主动在关闭之前通知服务器它将要被关闭，因此服务器根本不会有机会知道浏览器已经关闭。服务器会一直保留这个会话对象直到它处于非活动状态超过设定的间隔为止。 
   大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接到服务器时也就无法找到原来的session。 如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求报头，把原来的session id发送到服务器，则再次打开浏览器仍然能够找到原来的session。 
   恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为session设置了一个失效时间，当距离客户上一次使用session的时间超过了这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 
   **由此我们可以得出如下结论：** 
   关闭浏览器，只会是浏览器端内存里的session cookie消失，但不会使保存在服务器端的session对象消失，同样也不会使已经保存到硬盘上的持久化cookie消失。



### 10.整数相除之后还是整数，会丢失掉小数部分的数值。

### 11.HashMap底层是数组+链表+红黑树（JDK1.8）来实现的，根据key的hash值查找对应的位桶。

1.当前索引数组为空，则将键值对以链表形式插入。

2.当前索引数组已经存在，则判断当前链表是红黑树还时链表，然后插入。如果是链表插入到最后一个，判断长度是否大于8，大于8将链表转成红黑树。

所以应该是**拉链法**解决冲突。

### 12.jvm

![image-20220910082223873](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082223873.png)



大多数 JVM    将内存区域划分为 **Method    Area（Non-Heap）（方法区）** ,**Heap（堆）** , **Program    Counter Register（程序计数器）** ,  **VM Stack（虚拟机栈，也有翻译成JAVA    方法栈的）,Native Method    Stack** （ **本地方法栈** ），其中**Method Area** 和     ***\*Heap\**** 是线程共享的     ***\*，VM \*\*Stack，Native Method Stack 和\*\*Program          Counter Register\*\*\*\*\****       是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 

  首先我们熟悉一下一个一般性的  Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class  为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM  通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 

​    概括地说来，JVM初始运行的时候都会分配好 **Method  Area（方法区）** 和**Heap（堆）** ，而JVM    每遇到一个线程，就为其分配一个 **Program Counter    Register（程序计数器）** ,  **VM Stack（虚拟机栈）和Native Method  Stack （本地方法栈），** 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。

即，方法区用于存储JVM加载的类信息以及类相关的东西，比如类变量、常量等，是线程隔离的，但是编译器编译后的代码等数据，是线程共享的

![image-20220910082609831](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082609831.png)

### 13.

java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？

```
1 4 8 2 4 8 1
```

### 14.

成员变量与局部变量的区别 1、在类中的位置不同 成员变量：在类中方法外面 局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中） 2、在内存中的位置不同，可以看看Java程序内存的简单分析 成员变量：在堆中（方法区中的静态区） 局部变量：在栈中 3、生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失 4、初始值 成员变量：有默认初始值 局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized）

### 15.Java 中堆和栈有什么区别？

  JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

        栈：在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
    
        堆：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。



### 16.接口无构造函数，抽象类不允许多继承

抽象类可以有构造函数，毕竟是类。 但是不能实例化。 1.8加入了default和静态方法，可以有方法体

### 17.构造方法的作用是初始化成员变量

### 18.

java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。

### 19.

接口和抽象类的区别：
 1.接口的方法默认为public abstract ,接口中的变量默认为public static final，在java8之前所有的方法不能有实现
 抽象类中可以有非抽象方法
 2.一个类可以实现多个接口，但只能继承一个抽象类
 3.一个类实现接口，要实现该接口的所有抽象方法。
 4.接口不能被实例化，但可以声明，但是必须引用一个实现该接口的对象。
 抽象类可以有构造方法，但是不能被直接通过new进行实例化。但可以通过子类继承，实例化子类的时候抽象类也会被实例化。
 这其实用到了多态，向上转型。父类引用指向子类对象。
 5.从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。



### 20.jsp

给定includel.isp文件代码片段，如下：
   <% pageContext.setAttribute(“User”,”HAHA”);%>
  ______ // 此处填写代码
   给定include2.jsp文件代码片段如下：
   <%=pageContext.getAttribute(“User”)%>
   要求运行include1.jsp时，浏览器上输出：HAHA
                                        

- ```
  &lt;jsp:include page=&rdquo;include2.jsp&rdquo; flash=&rdquo;true&rdquo;&gt;
  ```

- ```
  &lt;%@include file=&rdquo;include2.jsp&rdquo;%&gt;
  ```

- ```
  &lt;jsp:forward page=&rdquo;include2.jsp&rdquo;&gt;
  ```

- ```
  &lt;% response.sendRedirect(&ldquo;include2.jsp&rdquo;); %&gt;
  ```

A选项使用了jsp中动作标签的包含标签，这里是动态包含。原理是包含与被包含的页面单独翻译成不同的java文件，然后运行时合并在一起。因为是存在域中的数据，故刚开始就直接翻译数据还不存在，因此浏览器上不能显示出HAHA。 

  B选项使用了jsp三大指令中的包含指令，这里是静态包含。原理是直接把包含与被包含页面的内容先合并在一起，然后翻译成一个java源文件，最后编译执行。故可以在浏览器上显示出HAHA。 

  C和D选项分别使用了跳转和重定向，我们知道jsp中有四个域对象，从小到大分别为： 

- ​    page域：在同一个jsp页面中数据有效      
- ​    request域：在同一个请求中数据有效      
- ​    session域：在用一个会话中数据有效      
- ​    application域：在同一个网站中数据有效     

 题中使用的是page域对象：pageContext，而C选项应该使用request域对象：HttpServletRequest，而D选项应该至少使用session域对象：HttpSession（如果处于同一会话中）。



### 21.super

1、子类构造函数调用父类构造函数用super 2、子类重写父类方法后，若想调用父类中被重写的方法，用super 3、未被重写的方法可以直接调用。

### 22.泛型只是提高了数据传输安全性，并没有改变程序运行的性能

### 23.

1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。



### 24.

![image-20220912142132565](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220912142132565.png)

### 25.

类变量在不设置初始值时，会进行默认赋值，而局部变量（方法中的变量）必须进行初始化，不会进行默认的赋值，Java中基本数据类型默认值为： 　　short: 0 　　int: 0 　　long:0 　　float: 0.0 　　double: 0.0 　　char:0 　　String:null 　　Java中对象引用默认值为null

### 26.关于静态方法

静态只能调用静态，非静态既可以调用静态也可以非静态



### 27.

Thread类中start()和run()方法的使用的不同。start()方法真正启动线程，让线程处于就绪状态，一旦得到时间片，则会调用线程的run()方法进行到运行状态。而run()方法只是一个普通方法调用而已，可以直接理解为调用方法A()。

类似的考题还有wait()和sleep()方法的比较。

① 这两个方法来自 不同的类 分别是，sleep来自Thread类，和wait来自Object类。



② 锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。

③ 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

  synchronized(x){ 
   x.notify() 
   //或者wait() 

  }



### 28.

在方法中改变了对象的引用，指的是仅仅改变引用而已，对象还是那个对象。

**就相当于你银行卡丢了，你重新补办换了一张卡，变的是银行卡，而你卡里的钱一分都没少。**



> 1.Java中没有指针，所以也没有引用传递了，仅仅有值传递。不过，可以通过对象的方式来实现引用传递。类似java没有多继承，但可以用多次implements接口实现多继承的功能。
>
> 2.在Java应用程序中永远不会传递对象，而只**传递对象的引用**。因此是按**引用传递对象**。但重要的是要区分参数是如何传递的。
>
> 3.Java应用程序**按引用传递对象**这一事实并不意味着 Java 应用程序按引用传递参数。参数可以是对象引用，而 Java应用程序是**按值传递对象引用的。**
>
> 4.Java应用程序中的变量可以为以下两种类型之一：引用类型或基本类型。当作为参数传递给一个方法时，处理这两种类型的方式是相同的。**两种类型都是按值传递的，**没有一种按引用传递。

```
链接：https://www.nowcoder.com/questionTerminal/72096d298bd344168441361f9c16659c
来源：牛客网

解析: 注意!Java中方法的参数传递都是值传递
A. 在方法中，修改一个基础类型的参数不会影响原始参数值
1
2
3
4
5
6
7
8
9
10
11
public static void main(String []args){
    int i = 5;   
    func(i);
    System.out.println(i);
}
static void func(int j){
    j = 10;
}
 
//输出结果
5
在主方法调用func(int j) 时 , 参数i是实际参数 , 值为5 , 参数j是形式参数 , 值是i给的 , 也是5 , i和j没有任何关系 , 是两个独立的参数 , 所以修改j的值时与i没有关系 , 仍然输出5。

B. 在方法中，改变一个对象参数的引用不会影响到原始引用
1
2
3
4
5
6
7
8
9
10
11
12
13
public static void main(String []args){
    User rabbiter = new User();
    rabbiter.setName("rabbiter");
    func(rabbiter);
    System.out.println(rabbiter.getName());
}
static void func(User user){
    user = new User();
    user.setName("zhangsan");
}
 
//输出结果
rabbiter
在主方法调用func(User user) 时 , 对象rabbiter保存的是一个地址值 , 本质上就是把rabbiter的地址值给了形参user , 所以此时实参rabbiter和形参user指向在堆中的同一个对象 , 他们的地址值相同 , 只是指向的对象一致 , 所以并不违反值传递的理论。
此时 , 如果修改形参user , new一个新的对象并让user指向它 , 修改的只是形参保存的地址 , 与实参rabbiter无关 , rabbiter指向的对象仍然是之前的那个对象。

C. 在方法中，修改一个对象的属性会影响原始对象参数
1
2
3
4
5
6
7
8
9
10
11
12
public static void main(String []args){
    User rabbiter = new User();
    rabbiter.setName("rabbiter");
    func(rabbiter);
    System.out.println(rabbiter.getName());
}
static void func(User user){
    user.setName("zhangsan");
}
 
//输出结果
zhangsan
在主方法调用func(User user) 时 , 对象rabbiter保存的是一个地址值 , 本质上就是把rabbiter的地址值给了形参user , 所以此时实参rabbiter和形参user指向在堆中的同一个对象 , 他们的地址值相同 , 指向的对象一致 , 所以并不违反值传递的理论。
那么user对其指向的对象的属性name进行修改 , rabbiter指向的对象的name属性也就被修改了。

D. 在方法中，修改集合和Maps的元素不会影响原始集合参数
集合和Maps都是对象 , 所以此项跟C选项的解析一致。
```



### 29.

![image-20220913101121668](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220913101121668.png)



### 30



Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.

### 31

JAVA语言中定义了8种基本的数据类型，来保存变量。JAVA要求程序中的每一个变量都规定自己的类型。正因为如此，JAVA属于强类型语言，从而不同于JavaScript这样的弱类型脚本语言。
 下面我们来看看这8种类型： 
byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。
short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。
int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。
long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。
float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。
double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。
boolean：只有true和false两个取值。
char：16位，存储Unicode码，用单引号赋值。
注：一个字节=8位。
所以，整型数据类型中，需要内存空间最多的是long。

### 32

数据类型转换，遵循一个原则：范围小的转到范围大的自动进行转换，范围大的转为范围小的要进行强制类型转换

> 自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下： 
>  低 ---------------------------------------------> 高 
>  byte,short,char-> int -> long -> float -> double
>  其中虽然float占4个字节，long占8个字节，因为底层的实现方式不同，float大于long

### 33抽象类

***\*jdk1.8之前\****  

  ***\*接口\****  

  1.多实现  

  2.变量类型默认且只能为为public static final  

  3.函数类型默认且只能为public，只能有public类型的静态成员函数  

  4.非静态成员函数没有方法体，静态成员函数有方法体  

  5.子类必须实现所有接口函数  

  6.可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数  

  7.没有构造器  

   

  ***\*抽象类\****  

  1.单继承  

  2.变量类型不限（静态变量+非静态变量）  

  3.函数类型不限（静态函数+非静态函数）  

  4.非静态函数包含没有方法体的抽象函数. 有方法体的普通函数  

  5.子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法  

  6.可以有main方法；不可以new一个抽象类  

  7.可以有构造器  

​    

  ***\*Jdk1.8\****  

  ***\*接口中可以有default类型的方法，实现类可以选择实现该方法\****  

  ***\*意义：\****默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。另一个优势为该方法是可选的，子类可以根据不同的需求Override或默认实现。

### 34编码

1.不同的编码格式，字符所占用的字节数是不一样的。如GBK中每个中文占用2个字节，UTF-8中则是变长编码，可能占用3个字节或者4个字节。因此A不正确。 

  2.不同的编码方式之间是可以转换的，如果数据库GBK编码，页面上可以使用任意支持汉字编码的编码方式显示都可以，只要在向页面传输的数据过程中进行编码的转换即可。如：数据库是GBK，页面上是UTF-8,那么可以这样转换：实例代码以java语法编写 

[复制代码](#)

```
byte``[] bytesGBK = readContentFromDatabase(); ``// 从数据库读取的字符数据，GBK编码``String str = ``new` `String(bytesGBK, Charset.forName(``"GBK"``)); ``// GBK编码转换成字符串``// 在向页面传输时，将字符串转换成UTF-8编码的数据流``Writer out = getResponseWriter();``response.setContentType(``"text/plain;charset=utf-8"``); ``// 指定内容的编码格式是UTF-8``out.write(str.getByte(``"UTF-8"``)); ``// 写入UTF-8数据流
```

  3.Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符。

  4.ResourceBundle能够按Local的不同，优先读取对应后缀的properties文件，这个是java中自带的。使用的地方很多。

### 35.Hashtable与HashMap

**Hashtable**：

（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。

（2）Hashtable 的函数都是同步的，这意味着它是**线程安全**的。它的key、value都不可以为null。

（3）HashTable直接使用对象的hashCode。

**HashMap：**

（1）由**数组+链表**组成的，基于**哈希表的Map**实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。

（3）HashMap重新计算hash值

**Hashtable,HashMap,Properties**继承关系如下：

```
public` `class` `Hashtable<K,V> ``extends` `Dictionary<K,V>``  ``implements` `Map<K,V>, Cloneable, java.io.Serializable` `public` `class` `HashMap<K,V>``extends` `AbstractMap<K,V> ``implements` `Map<K,V>, Cloneable, Serializable
```

[复制代码](https://www.nowcoder.com/test/question/done?tid=61320447&qid=57787#)

```
java.lang.Objecct`` ``java.util.Dictionary<K,V>``  ``java.util.Hashtable<Object,Object>``   ``java.util.Properties 
```



### 36重载

重载是Java多态性（在一个类中）的一种表现方式，要注意以下几点：

  1.参数列表不同。包括参数个数、参数类型、参数顺序等的不同；

  2.不能通过方法的访问权限、返回值类型和抛出的异常类型来判断重载；

  3.对于继承来说，如果父类方法的访问权限为private，那么就不能在子类对其重载；如果子类也定义了一个同名的函数，只是一个新方法，并不是重载方法。

### 37&运算

&运算符：两个数都转为二进制，然后从两个数的最高位进行与运算，两个都为真（1），结果才为真（1），否则为假（0）

13：01101
17：10001
结果：00001，既为1



### 38包装类与基本数据类型

基本类型存储在栈里，包装类型存储在堆里。因为栈的效率更高，所以保留了基本类型

```
long和double都占了64位（64bit）的存储空间
```

默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f 

基本数据类型是没有静态方法的，但是基本数据类型的包装类却有

### 39final与abstract

final修饰类时，此类**不能被继承**，但是**可以创建对象**。如包装类（Double、Float等等），String类也是。（所以B错误）

顺便补充一下final修饰方法和属性时的细节：

1. final修饰方法时，子类不能重写该方法； 
2. final修饰不了构造方法； 
3. final修饰属性时，此属性不能被更改，并且必须被赋值。 

abstract修饰类时，表示抽象类。该类**不能被实例化**，即不能创建对象。一般来说，创建抽象类，需要子类来实现抽象方法，所以可以被继承。（所以A正确）
正因为抽象类需要子类来实现，所以与final修饰的类（不能被继承）相违背（所以C正确）。
抽象类不一定要包含abstract方法，但是一旦类包含了abstract方法，则这个类必须声明为abstract（所以D正确）

### 40基本类型与包装类比较

![image-20220915092811449](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915092811449.png)

### 41局部变量与静态变量

![image-20220915092949186](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915092949186.png)

```
a=11 t.a=2
```





### 42Java中的异常分类:  

 可分为:   
 RuntimeException: 
 运行时异常(战之过,程序员的过错),也叫做unchecked Exception, 非编译期异常(编译器检查不出来,只有运行时才能显现出来的异常,叫做非编译异常,或者运行时异常,一般是由于程序员逻辑错误引起的,如空指针异常,数组越界异常等,所以称之为战之过)   

 Exception中除了RuntimeException之外的所有异常,比如IOException,SQLException等    
 非运行时异常(非战之过),也叫做检查异常(check Exception) ,编译异常(编译期可以检查出来的异常,不需要运行就可以检测到的异常,比如IOException,SQLException,等预期之内的异常,因为可以预料到,因此是必须检查的异常,所以,也叫做check Exception)  

 常见的,IOException,SQLException,等所有继承与Exception,但是不继承与RuntimeException的,都属于非运行时异常,是必须在编写程序的时候就要throw的  
 所有继承与RuntimeException的,都是程序员逻辑错误引起的异常,比如空指针异常等,是unchecked Exception  

![image-20220915093357505](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915093357505.png)
