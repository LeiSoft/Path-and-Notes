# 牛客网刷题小记

## MySQL
### 1.查询语句执行顺序

（8）Select
（9）distinct 字段名1,字段名2，
（6）[fun(字段名)]  
（1）from 表1
（3）<join类型>join 表2 
（2）on <join条件> 
（4）where <where条件> 
（5）group by <字段> 
（7）having <having条件> 
（10）order by <排序字段> 
（11）limit <起始偏移量,行数>

### 2.使用聚合函数，则判断条件使用having

where---过滤指定的行
having--过滤分组，与group by连用
返回订单数量总和不小于100:having sum(quantity)>= 100

### 3.返回同一表中的字段及字段别名，group、order同时使用

返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines对结果进行升序排序。
SELECT 
    order_num,
    COUNT(order_num) order_lines
FROM
    OrderItems
GROUP BY
    order_num
ORDER BY
    order_lines;

### 4.

可以使用ORDER BY，GROUP BY和HAVING子句中的列别名来引用该列。
不能在WHERE子句中使用列别名。原因是当MySQL评估求值WHERE子句时，SELECT子句中指定的列的值可能尚未确定。

### 5.MYSQL中何时使用group by

1）当聚合列和非聚合列出现在一起时必须使用group by,如:
#emp为员工表,deptno为部门编号字段,sal为工资字段
SELECT deptno,MAX(sal),AVG(sal) FROM emp
GROUP BY deptno #按照部门分组

当使用group by时,应使用非聚合列为分组依据.

2）什么是聚合列
聚合列是指根据需求算出结果的列,
常使用的聚合列函数有
count(求个数),
sum(求合),
max(求最大值),
min(求最小值),
avg(求平均数)

#emp为员工表,sal为工资字段

#求emp字段一共有几条数据
select count(*) from emp
#求员工工资总和
select sum(sal) from emp
#求员工最高工资
select max(sal) from emp
#求员工最低工资
select min(sal) from emp
#求员工平均 工资
select avg(sal) from emp

3）having条件查询
当使用group by进行分组时,想要使用条件查询,必须使用having,而不是where

#查询平均工资小于8000的部门
#emp为员工表,deptno为部门编号字段,sal为工资字段
select deptno, AVG(sal) from emp
group by deptno #按部门分组
having AVG(sal)<8000 #查询条件,类似where,但是group by中只能使用having
将两个 SELECT 语句结合起来（一）#
发表于 04-28 17:08
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;

### 6.union

union--连接表，对行操作。
union--将两个表做行拼接，同时自动删除重复的行。
union all---将两个表做行拼接，保留重复的行
【问题】
    将两个 SELECT 语句结合起来，以便从 OrderItems表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。
    
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;
select *  from OrderItems where quantity=100
union
select * from OrderItems where prod_id like "BNBG%"
order by prod_id;

使用union组合查询时，只能使用一条order by字句，他必须位于最后一条select语句之后，因为对于结果集不存在对于一部分数据进行排序，而另一部分用另一种排序规则的情况。 

## java
### 1.HttpServlet容器响应Web客户请求流程如下：

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

### 2.try块中放置可能引发异常的代码 故不可被省略

Jdk1.7中新增了多个catch块的功能，用以捕获多异常， 捕获顺序为先小后大
finally块用作回收无法被JVM回收的物理资源 例如数据库链接 网络链接等 Jdk1.7中虽增强了try()的功能，使得其中的代码在程序执行完毕后自动关闭代码 相当与隐含finally块
catch块用作捕获异常
总结
异常处理语法结构中只有try块是必须的，但不能只有try块，1.7中的增强try除外 因为其中的try()已经隐含了finally了 
通常一个类实现序列化方式是实现序列化接口 Serializable

### 3.序列化

序列化的作用：把数据长久的保存在磁盘中，磁盘和内存是不同的，内存一般在程序运行时占用，数据保存周期短，随程序结束而结束，磁盘可以长久保存数据

transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，就这个作用------在已序列化的类中使变量不序列化

### 4.super

特殊变量super，提供了对父类的访问。

可以使用super访问父类被子类隐藏的变量或覆盖的方法。

每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

构造是不能被继承的。

### 5.规范

1、项目名全部小写.
2、包名全部小写.
3、类名首字母大写,其余组成词首字母依次大写.
4、变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写.
5、常量名全部大写.
6、所有命名规则必须遵循以下规则 :

名称只能由字母、数字、下划线、$符号组成.
不能以数字开头.
名称不能使用Java中的关键字.
坚决不允许出现中文及拼音命名.

### 5.public,protected,private,default详解

![image-20220908095551242](D:\HOLY\Pate&Notes\markdown\学习小记\assets\image-20220908095551242.png)

public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不
　　　　　仅可以跨类访问，而且允许跨包（package）访问。
[private](https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020): Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以
　　　　　及方法只能被该类的对象访问，其[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)不能访问，更不能允许跨包访问。
protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、
　　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。
default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访
　　　　　问。



### 6.Java数据库连接库JDBC用到哪种设计模式?

**JDBC使用的是桥接模式**

**定义:将抽象部分与它的实现部分分离,使它们都可以独立的变化**

**意图:将抽象与实现解耦**



### 7.

在Java中数据域和方法都必须属于某一个对象。不能单独存在，没有C++中的全局变量和方法一说。对象必须属于某一个类。**

对象中可以什么也没有**

数据域可以是基本数据类型，也可以是引用类型。**

### 8.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）

```
this(x)
```

### 9.关于cookie和session

  程序一般都是在用户做log off的时候发个指令去删除session，然而浏览器从来不会主动在关闭之前通知服务器它将要被关闭，因此服务器根本不会有机会知道浏览器已经关闭。服务器会一直保留这个会话对象直到它处于非活动状态超过设定的间隔为止。 
   大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接到服务器时也就无法找到原来的session。 如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求报头，把原来的session id发送到服务器，则再次打开浏览器仍然能够找到原来的session。 
   恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为session设置了一个失效时间，当距离客户上一次使用session的时间超过了这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 
   **由此我们可以得出如下结论：** 
   关闭浏览器，只会是浏览器端内存里的session cookie消失，但不会使保存在服务器端的session对象消失，同样也不会使已经保存到硬盘上的持久化cookie消失。



### 10.整数相除之后还是整数，会丢失掉小数部分的数值。

### 11.HashMap底层是数组+链表+红黑树（JDK1.8）来实现的，根据key的hash值查找对应的位桶。

1.当前索引数组为空，则将键值对以链表形式插入。

2.当前索引数组已经存在，则判断当前链表是红黑树还时链表，然后插入。如果是链表插入到最后一个，判断长度是否大于8，大于8将链表转成红黑树。

所以应该是**拉链法**解决冲突。

### 12.jvm

![image-20220910082223873](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082223873.png)



大多数 JVM    将内存区域划分为 **Method    Area（Non-Heap）（方法区）** ,**Heap（堆）** , **Program    Counter Register（程序计数器）** ,  **VM Stack（虚拟机栈，也有翻译成JAVA    方法栈的）,Native Method    Stack** （ **本地方法栈** ），其中**Method Area** 和     ***\*Heap\**** 是线程共享的     ***\*，VM \*\*Stack，Native Method Stack 和\*\*Program          Counter Register\*\*\*\*\****       是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 

  首先我们熟悉一下一个一般性的  Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class  为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM  通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 

​    概括地说来，JVM初始运行的时候都会分配好 **Method  Area（方法区）** 和**Heap（堆）** ，而JVM    每遇到一个线程，就为其分配一个 **Program Counter    Register（程序计数器）** ,  **VM Stack（虚拟机栈）和Native Method  Stack （本地方法栈），** 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。

即，方法区用于存储JVM加载的类信息以及类相关的东西，比如类变量、常量等，是线程隔离的，但是编译器编译后的代码等数据，是线程共享的

![image-20220910082609831](D:\HOLY\Pate&Notes\markdown\学习小记\assets\image-20220910082609831.png)

### 13.

java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？

```
1 4 8 2 4 8 1
```

### 14.

成员变量与局部变量的区别 1、在类中的位置不同 成员变量：在类中方法外面 局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中） 2、在内存中的位置不同，可以看看Java程序内存的简单分析 成员变量：在堆中（方法区中的静态区） 局部变量：在栈中 3、生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失 4、初始值 成员变量：有默认初始值 局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized）

### 15.Java 中堆和栈有什么区别？

  JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

        栈：在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
    
        堆：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。



### 16.接口无构造函数，抽象类不允许多继承

抽象类可以有构造函数，毕竟是类。 但是不能实例化。 1.8加入了default和静态方法，可以有方法体

### 17.构造方法的作用是初始化成员变量

### 18.

java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。

### 19.

接口和抽象类的区别：
 1.接口的方法默认为public abstract ,接口中的变量默认为public static final，在java8之前所有的方法不能有实现
 抽象类中可以有非抽象方法
 2.一个类可以实现多个接口，但只能继承一个抽象类
 3.一个类实现接口，要实现该接口的所有抽象方法。
 4.接口不能被实例化，但可以声明，但是必须引用一个实现该接口的对象。
 抽象类可以有构造方法，但是不能被直接通过new进行实例化。但可以通过子类继承，实例化子类的时候抽象类也会被实例化。
 这其实用到了多态，向上转型。父类引用指向子类对象。
 5.从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。



### 20.jsp

给定includel.isp文件代码片段，如下：
   <% pageContext.setAttribute(“User”,”HAHA”);%>
  ______ // 此处填写代码
   给定include2.jsp文件代码片段如下：
   <%=pageContext.getAttribute(“User”)%>
   要求运行include1.jsp时，浏览器上输出：HAHA
                                        

- ```
  &lt;jsp:include page=&rdquo;include2.jsp&rdquo; flash=&rdquo;true&rdquo;&gt;
  ```

- ```
  &lt;%@include file=&rdquo;include2.jsp&rdquo;%&gt;
  ```

- ```
  &lt;jsp:forward page=&rdquo;include2.jsp&rdquo;&gt;
  ```

- ```
  &lt;% response.sendRedirect(&ldquo;include2.jsp&rdquo;); %&gt;
  ```

A选项使用了jsp中动作标签的包含标签，这里是动态包含。原理是包含与被包含的页面单独翻译成不同的java文件，然后运行时合并在一起。因为是存在域中的数据，故刚开始就直接翻译数据还不存在，因此浏览器上不能显示出HAHA。 

  B选项使用了jsp三大指令中的包含指令，这里是静态包含。原理是直接把包含与被包含页面的内容先合并在一起，然后翻译成一个java源文件，最后编译执行。故可以在浏览器上显示出HAHA。 

  C和D选项分别使用了跳转和重定向，我们知道jsp中有四个域对象，从小到大分别为： 

- ​    page域：在同一个jsp页面中数据有效      
- ​    request域：在同一个请求中数据有效      
- ​    session域：在用一个会话中数据有效      
- ​    application域：在同一个网站中数据有效     

 题中使用的是page域对象：pageContext，而C选项应该使用request域对象：HttpServletRequest，而D选项应该至少使用session域对象：HttpSession（如果处于同一会话中）。



### 21.super

1、子类构造函数调用父类构造函数用super 2、子类重写父类方法后，若想调用父类中被重写的方法，用super 3、未被重写的方法可以直接调用。

### 22.泛型只是提高了数据传输安全性，并没有改变程序运行的性能

### 23.

1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。

(不管你try中有没有return，finally中的代码一定会执行。当try中有return，但是finally中没有，则finally中的代码在try中return执行前执行；当两者中均有return，那么先执行finally中return之前的代码，然后执行try中return，最后执行finally中的return!!!)

### 24.

![image-20220912142132565](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220912142132565.png)

### 25.

类变量在不设置初始值时，会进行默认赋值，而局部变量（方法中的变量）必须进行初始化，不会进行默认的赋值，Java中基本数据类型默认值为： 　　short: 0 　　int: 0 　　long:0 　　float: 0.0 　　double: 0.0 　　char:0 　　String:null 　　Java中对象引用默认值为null

### 26.关于静态方法

静态只能调用静态，非静态既可以调用静态也可以非静态



### 27.

Thread类中start()和run()方法的使用的不同。start()方法真正启动线程，让线程处于就绪状态，一旦得到时间片，则会调用线程的run()方法进行到运行状态。而run()方法只是一个普通方法调用而已，可以直接理解为调用方法A()。

类似的考题还有wait()和sleep()方法的比较。

① 这两个方法来自 不同的类 分别是，sleep来自Thread类，和wait来自Object类。



② 锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。

③ 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

  synchronized(x){ 
   x.notify() 
   //或者wait() 

  }



### 28.

在方法中改变了对象的引用，指的是仅仅改变引用而已，对象还是那个对象。

**就相当于你银行卡丢了，你重新补办换了一张卡，变的是银行卡，而你卡里的钱一分都没少。**



> 1.Java中没有指针，所以也没有引用传递了，仅仅有值传递。不过，可以通过对象的方式来实现引用传递。类似java没有多继承，但可以用多次implements接口实现多继承的功能。
>
> 2.在Java应用程序中永远不会传递对象，而只**传递对象的引用**。因此是按**引用传递对象**。但重要的是要区分参数是如何传递的。
>
> 3.Java应用程序**按引用传递对象**这一事实并不意味着 Java 应用程序按引用传递参数。参数可以是对象引用，而 Java应用程序是**按值传递对象引用的。**
>
> 4.Java应用程序中的变量可以为以下两种类型之一：引用类型或基本类型。当作为参数传递给一个方法时，处理这两种类型的方式是相同的。**两种类型都是按值传递的，**没有一种按引用传递。

```
链接：https://www.nowcoder.com/questionTerminal/72096d298bd344168441361f9c16659c
来源：牛客网

解析: 注意!Java中方法的参数传递都是值传递
A. 在方法中，修改一个基础类型的参数不会影响原始参数值
1
2
3
4
5
6
7
8
9
10
11
public static void main(String []args){
    int i = 5;   
    func(i);
    System.out.println(i);
}
static void func(int j){
    j = 10;
}
 
//输出结果
5
在主方法调用func(int j) 时 , 参数i是实际参数 , 值为5 , 参数j是形式参数 , 值是i给的 , 也是5 , i和j没有任何关系 , 是两个独立的参数 , 所以修改j的值时与i没有关系 , 仍然输出5。

B. 在方法中，改变一个对象参数的引用不会影响到原始引用
1
2
3
4
5
6
7
8
9
10
11
12
13
public static void main(String []args){
    User rabbiter = new User();
    rabbiter.setName("rabbiter");
    func(rabbiter);
    System.out.println(rabbiter.getName());
}
static void func(User user){
    user = new User();
    user.setName("zhangsan");
}
 
//输出结果
rabbiter
在主方法调用func(User user) 时 , 对象rabbiter保存的是一个地址值 , 本质上就是把rabbiter的地址值给了形参user , 所以此时实参rabbiter和形参user指向在堆中的同一个对象 , 他们的地址值相同 , 只是指向的对象一致 , 所以并不违反值传递的理论。
此时 , 如果修改形参user , new一个新的对象并让user指向它 , 修改的只是形参保存的地址 , 与实参rabbiter无关 , rabbiter指向的对象仍然是之前的那个对象。

C. 在方法中，修改一个对象的属性会影响原始对象参数
1
2
3
4
5
6
7
8
9
10
11
12
public static void main(String []args){
    User rabbiter = new User();
    rabbiter.setName("rabbiter");
    func(rabbiter);
    System.out.println(rabbiter.getName());
}
static void func(User user){
    user.setName("zhangsan");
}
 
//输出结果
zhangsan
在主方法调用func(User user) 时 , 对象rabbiter保存的是一个地址值 , 本质上就是把rabbiter的地址值给了形参user , 所以此时实参rabbiter和形参user指向在堆中的同一个对象 , 他们的地址值相同 , 指向的对象一致 , 所以并不违反值传递的理论。
那么user对其指向的对象的属性name进行修改 , rabbiter指向的对象的name属性也就被修改了。

D. 在方法中，修改集合和Maps的元素不会影响原始集合参数
集合和Maps都是对象 , 所以此项跟C选项的解析一致。
```



### 29.

![image-20220913101121668](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220913101121668.png)



### 30



Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.

### 31

JAVA语言中定义了8种基本的数据类型，来保存变量。JAVA要求程序中的每一个变量都规定自己的类型。正因为如此，JAVA属于强类型语言，从而不同于JavaScript这样的弱类型脚本语言。
 下面我们来看看这8种类型： 
byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。
short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。
int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。
long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。
float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。
double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。
boolean：只有true和false两个取值。
char：16位，存储Unicode码，用单引号赋值。
注：一个字节=8位。
所以，整型数据类型中，需要内存空间最多的是long。

### 32

数据类型转换，遵循一个原则：范围小的转到范围大的自动进行转换，范围大的转为范围小的要进行强制类型转换

> 自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下： 
>  低 ---------------------------------------------> 高 
>  byte,short,char-> int -> long -> float -> double
>  其中虽然float占4个字节，long占8个字节，因为底层的实现方式不同，float大于long

### 33抽象类和接口

***\*jdk1.8之前\****  

  ***\*接口\****  

  1.多实现  

  2.变量类型默认且只能为为public static final  

  3.函数类型默认且只能为public，只能有public类型的静态成员函数  

  4.非静态成员函数没有方法体，静态成员函数有方法体  

  5.子类必须实现所有接口函数  

  6.可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数  

  7.没有构造器  

   

  ***\*抽象类\****  

  1.单继承  

  2.变量类型不限（静态变量+非静态变量）  

  3.函数类型不限（静态函数+非静态函数）  

  4.非静态函数包含没有方法体的抽象函数. 有方法体的普通函数  

  5.子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法  

  6.可以有main方法；不可以new一个抽象类  

  7.可以有构造器  



​    接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。另外，接口和抽象类在方法上有区别：  

1.抽象类可以有构造方法，接口中不能有构造方法。 

2.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

3.抽象类中可以有普通成员变量，接口中没有普通成员变量 

\4. 抽象类中的抽象方法的访问类型可以是public，protected和默认类型

\5. 抽象类中可以包含静态方法，接口中不能包含静态方法

\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型

\7. 一个类可以实现多个接口，但只能继承一个抽象类。二者在应用方面也有一定的区别：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。

  ***\*Jdk1.8\****  

  ***\*接口中可以有default、static类型的方法，实现类可以选择实现该方法\****  

  ***\*意义：\****默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。另一个优势为该方法是可选的，子类可以根据不同的需求Override或默认实现。

### 34编码

1.不同的编码格式，字符所占用的字节数是不一样的。如GBK中每个中文占用2个字节，UTF-8中则是变长编码，可能占用3个字节或者4个字节。因此A不正确。 

  2.不同的编码方式之间是可以转换的，如果数据库GBK编码，页面上可以使用任意支持汉字编码的编码方式显示都可以，只要在向页面传输的数据过程中进行编码的转换即可。如：数据库是GBK，页面上是UTF-8,那么可以这样转换：实例代码以java语法编写 

[复制代码](#)

```
byte``[] bytesGBK = readContentFromDatabase(); ``// 从数据库读取的字符数据，GBK编码``String str = ``new` `String(bytesGBK, Charset.forName(``"GBK"``)); ``// GBK编码转换成字符串``// 在向页面传输时，将字符串转换成UTF-8编码的数据流``Writer out = getResponseWriter();``response.setContentType(``"text/plain;charset=utf-8"``); ``// 指定内容的编码格式是UTF-8``out.write(str.getByte(``"UTF-8"``)); ``// 写入UTF-8数据流
```

  3.Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符。

  4.ResourceBundle能够按Local的不同，优先读取对应后缀的properties文件，这个是java中自带的。使用的地方很多。

### 35.Hashtable与HashMap

**Hashtable**：

（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。

（2）Hashtable 的函数都是同步的，这意味着它是**线程安全**的。它的key、value都不可以为null。

（3）HashTable直接使用对象的hashCode。

**HashMap：**

（1）由**数组+链表**组成的，基于**哈希表的Map**实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。

（3）HashMap重新计算hash值

**Hashtable,HashMap,Properties**继承关系如下：

```
public` `class` `Hashtable<K,V> ``extends` `Dictionary<K,V>``  ``implements` `Map<K,V>, Cloneable, java.io.Serializable` `public` `class` `HashMap<K,V>``extends` `AbstractMap<K,V> ``implements` `Map<K,V>, Cloneable, Serializable
```

[复制代码](https://www.nowcoder.com/test/question/done?tid=61320447&qid=57787#)

```
java.lang.Objecct`` ``java.util.Dictionary<K,V>``  ``java.util.Hashtable<Object,Object>``   ``java.util.Properties 
```



### 36重载

重载是Java多态性（在一个类中）的一种表现方式，要注意以下几点：

  1.参数列表不同。包括参数个数、参数类型、参数顺序等的不同；

  2.不能通过方法的访问权限、返回值类型和抛出的异常类型来判断重载；

  3.对于继承来说，如果父类方法的访问权限为private，那么就不能在子类对其重载；如果子类也定义了一个同名的函数，只是一个新方法，并不是重载方法。

### 37&运算

&运算符：两个数都转为二进制，然后从两个数的最高位进行与运算，两个都为真（1），结果才为真（1），否则为假（0）

13：01101
17：10001
结果：00001，既为1



### 38包装类与基本数据类型

基本类型存储在栈里，包装类型存储在堆里。因为栈的效率更高，所以保留了基本类型

```
long和double都占了64位（64bit）的存储空间
```

默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f 

基本数据类型是没有静态方法的，但是基本数据类型的包装类却有

### 39final与abstract

final修饰类时，此类**不能被继承**，但是**可以创建对象**。如包装类（Double、Float等等），String类也是。（所以B错误）

顺便补充一下final修饰方法和属性时的细节：

1. final修饰方法时，子类不能重写该方法； 
2. final修饰不了构造方法； 
3. final修饰属性时，此属性不能被更改，并且必须被赋值。 

abstract修饰类时，表示抽象类。该类**不能被实例化**，即不能创建对象。一般来说，创建抽象类，需要子类来实现抽象方法，所以可以被继承。（所以A正确）
正因为抽象类需要子类来实现，所以与final修饰的类（不能被继承）相违背（所以C正确）。
抽象类不一定要包含abstract方法，但是一旦类包含了abstract方法，则这个类必须声明为abstract（所以D正确）

### 40基本类型与包装类比较

![image-20220915092811449](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915092811449.png)

### 41局部变量与静态变量

![image-20220915092949186](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915092949186.png)

```
a=11 t.a=2
```





### 42Java中的异常分类:  

 可分为:   
 RuntimeException: 
 运行时异常(战之过,程序员的过错),也叫做unchecked Exception, 非编译期异常(编译器检查不出来,只有运行时才能显现出来的异常,叫做非编译异常,或者运行时异常,一般是由于程序员逻辑错误引起的,如空指针异常,数组越界异常等,所以称之为战之过)   

 Exception中除了RuntimeException之外的所有异常,比如IOException,SQLException等    
 非运行时异常(非战之过),也叫做检查异常(check Exception) ,编译异常(编译期可以检查出来的异常,不需要运行就可以检测到的异常,比如IOException,SQLException,等预期之内的异常,因为可以预料到,因此是必须检查的异常,所以,也叫做check Exception)  

 常见的,IOException,SQLException,等所有继承与Exception,但是不继承与RuntimeException的,都属于非运行时异常,是必须在编写程序的时候就要throw的  
 所有继承与RuntimeException的,都是程序员逻辑错误引起的异常,比如空指针异常等,是unchecked Exception  

![image-20220915093357505](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915093357505.png)

### 43



单例的目的是保证某个类仅有一个实例。当有某些类创建对象内存开销较大时可以考虑使用该模式。**单例模式又分为 饿汉式 和 懒汉式** 。下面分别说明： 

  1.饿汉式。顾名思义，该模式在类被加载时就会实例化一个对象。具体代码如下： 

  public class Person {
   //饿汉式单例
   private static Person person = new Person();
   private Person(){}

   public static Person getInstance(){
   return person;
   }
 }
 该模式能简单快速的创建一个单例对象，而且是**线程安全的(只在类加载时才会初始化，以后都不会)**。但它有一个缺点，就是不管你要不要都会直接创建一个对象，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单)

### 43

关于抽象类

JDK 1.8以前，抽象类的方法默认访问权限为protected

JDK 1.8时，抽象类的方法默认访问权限变为default

关于接口

JDK 1.8以前，接口中的方法必须是public的

JDK 1.8时，接口中的方法可以是public的，也可以是default的

JDK 1.9时，接口中的方法可以是private的

### 44

抽象类和接口的区别:

\1. 抽象类可以有构造方法，接口中不能有构造方法。

\2. 抽象类中可以有普通成员变量，接口中没有普通成员变量。

\3. 抽象类中可以包含非抽象普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。

\4. 抽象类中的抽象方法的访问权限可以是 public、protected 和默认类型，接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。

\5. 抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能不包含静态方法，JDK1.8 以后可以包含。

\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的，并且默认即为 public static final 类型。

\7. 一个类可以实现多个接口，用逗号隔开，但只能继承一个抽象类，接口不可以实现接口，但可以继承接口，并且可以继承多个接口，用逗号隔开。

```
如果是java 7，接口中可以包含的类容有：
1.常量
2.抽象方法

如果是java 8，还可以额外包含：
3.默认方法
4.静态方法

如果是java 9，还可以额外包含有：
5.私有方法
```

### 45取反公式

负数的补码 = 原码取反 + 1，即：

-n = ~n + 1    →  ~n = -n -1   

~j：~10 =  - 10 - 1 = -11

i + j = 5 + -11 = -6 

### 46

- ```
  Java网络编程API建立在Socket基础之上
  ```

- ```
  Java网络接口支持IP以上的所有高层协议
  ```

### 47序列化

- 序列化： **将Java对象或数据结构通过序列化机制转换成二进制字节流传输到网络其他节点或存储介质上。**
- 反序列化： **将网络或存储介质中的二进制字节流通过反序列化机制将其转换成Java对象或数据结构。**



 使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.

​    声明为static和transient类型的成员数据不能被串行化。因为static代表类的状态， transient代表对象的临时数据。

### 48



HashMap可以插入null的key或value，插入的时候，检查是否已经存在相同的key，如果不存在，则直接插入，如果存在，则用新的value替换旧的value，在本题中，第一条put语句，会将key/value对插入HashMap，而第二条put，因为已经存在一个key为name的项，所以会用新的value替换旧的vaue，因此，两条put之后，HashMap中只有一个key/value键值对。那就是（name，jack）。所以，size为1.

### 49

意思就是存的顺序 与取出来的顺序完全相反
 Stack 栈 先进后出
 Queue 队列 先进先出
 List 集合 有下标 存的顺序与取得的顺序一致
 LinedList 类 是Queue的子类 存的顺序与取得的顺序一致

### 50Switch

switch...case的三个规则： 

  （1）既无成功匹配，又无default子句，那么swtich语句块什么也不做； 

  （2）无成功匹配，但有default，那么swtich语句块做default语句块的事； 

  （3）有成功匹配，没有break，那么成功匹配后，一直执行，直到遇到break。

### 51

外部类：只能有两种访问控制级别，public 和 默认。外部类没有处于任何类的内部，因此private和public访问控制符没有任何意义。 

  成员内部类：位于类内部但不包括位于块、构造器、方法内，且有名称的类，修饰符有public,private,protected访问控制符，也可以用static,final关键字修饰。 

  局部内部类：位于块、构造器、方法内的有名称类，最多只能有final修饰。

![image-20220918171248204](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220918171248204.png)

### 52static

静态成员被所有对象共享

即如果某对象调用静态成员变量并修改了静态成员变量的值 那么所有的对象调用静态成员变量的值都将被修改

### 53精度

会产生信息丢失不如说**丢失精度**，这样可能更容易明白，而**精度丢失只会发生在从大范围到小范围的转换**

### 54

ArrayList和LinkedList在性能上各 有优缺点,都有各自所适用的地方,总的说来可以描述如下： 　

1．对ArrayList和LinkedList而言,在列表末尾增加一个元素所花的开销都是固定的.对 ArrayList而言,主要是在内部数组中增加一项,指向所添加的元素,偶尔可能会导致对数组重新进行分配；而对LinkedList而言,这个开销是统一的,分配一个内部Entry对象. 　

2．在ArrayList的 中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的

3．LinkedList不 支持高效的随机元素访问. 　

4．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间,而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 　可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了.

### 55

- String：不可变，线程安全；
- StringBuffer：可变，线程安全；
- StringBuilder：可变，线程不安全；

  B.同时用 abstract和final就会自相矛盾。 

抽象类不能声明为 `final`, 被声明为 `final` 的类无法被继承，很明显不符合抽象类的定义

  C.Hashmap中的value可以之null，get(key)==null有两种情况，一是key不存在，二是该key中存的是null，所以应该使用map.containskey(key)返回的true/false来判断是否存在这个key。 

  D.volatile关键字有两个作用： 

  1.并发环境可见性：volatile修饰后的变量能够保证该变量在线程间的可见性，线程进行数据的读写操作时将绕开工作内存（CPU缓存）而直接跟主内存进行数据交互，即线程进行读操作时直接从主内存中读取，写操作时直接将修改后端变量刷新到主内存中，这样就能保证其他线程访问到的数据是最新数据 

  2.并发环境有序性：通过对volatile变量采取内存屏障（Memory barrier）的方式来防止编译重排序和CPU指令重排序，具体方式是通过在操作volatile变量的指令前后加入内存屏障，来实现happens-before关系，保证在多线程环境下的数据交互不会出现紊乱

### 55volatile

出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。

### 56标识符

**标识符：**

  **1. 只能由数字，字母，符号（有且仅有_和$两个）组成。**

  **2. 数字不能作为标识符的开头。**

  **3. 不能和关键字，保留字，显式常量一样。关键字都是小写的。**

  **4. null，true，false都不是关键字，属于显式常量。goto，const都是保留关键字。**

### 57类修饰符

普通类（外部类）：只能用public、default（不写）、abstract、final修饰。 

（成员）内部类：可理解为外部类的成员，所以修饰类成员的public、protected、default、private、static等关键字都能使用。 

局部内部类：出现在方法里的类，不能用上述关键词来修饰。 

匿名内部类：给的是直接实现，类名都没有，没有修饰符。

### 58构造方法

构造方法是一种特殊的方法，具有以下特点。    （1）构造方法的方法名必须与类名相同。    （2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。    （3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。     （4）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。    （5）构造方法可以重载，以参数的个数，类型，顺序。

### 59JAVA得变量声明方式可以避免程序在多线程竞争

- ```A
  A volatile
  ```

- ```
  B static volatile
  ```

A B选项，免程序在多线程竞争情况下读到不正确的值需要保证内存可见性，即当一个线程修改了volatile修饰的变量的值，volatile会保证新值立即同步到主内存，以及每次使用前立即从主内存读取。 

  C选项，synchronized可以修饰方法、代码块或对象，并不修饰变量。 

  D选项，static修饰的变量属于类，线程在使用这个属性的时候是从类中复制拷贝一份到线程工作内存中的，如果修改线程内存中的值之后再写回到原先的位置，就会有线程安全问题。用static修饰的变量可见性是无法确保的。

### 60封装

**1** **、什么是封装？**

**封装就是将属性私有化，提供公有的方法访问私有属性。------------------- 所以CD错误。**

做法就是：修改属性的可见性来限制对属性的访问，并为每个属性创建一对取值（ getter ）方法和赋值（ setter ）方法，用于对这些属性的访问。

如： private String name;

public String getName(){

​          return;

​      }

​    public void setName(String name){

​          this.name=name;

​      }

**2、**   **为什么需要封装？**

  **通过封装，可以实现对属性的数据访问限制，同时增加了程序的可维护性。**

  **由于取值方法和赋值方法隐藏了实现的变更，因此并不会影响读取或修改该属性的类，避免了大规模的修改，程序的可维护性增强**



### 61

关于String、StringBuffer、StringBuilder区别总结： 

  1.可变不可变 

  String用final修饰，所以string对象是不可变的 

  StringBuffer和StringBuilder都是继承AbstratStringBuilder，在AbstratStringBuilder中是使用字符串数组保存字符串，由此可知这两种对象是可变的 

  2.线程安全 

  String对象是不可变的，可以理解为常量，所以是线程安全的 

  StringBuffer对方法加了同步锁或者对被调用的方法加了同步锁，所以是线程安全的 

  StringBuilder没有对方法加同步锁，所以是非线程安全的 

  3.效率 

  String<StringBuffer<StringBuilder 

### 62



1.Statement、PreparedStatement和CallableStatement都是接口(interface)。 

2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。 
\3. 
Statement接口提供了执行语句和获取结果的基本方法； 
PreparedStatement接口添加了处理 IN 参数的方法； 
CallableStatement接口添加了处理 OUT 参数的方法。 
\4. 
a.Statement: 
普通的不带参的查询SQL；支持批量更新,批量删除; 
b.PreparedStatement: 
可变参数的SQL,编译一次,执行多次,效率高; 
安全性好，有效防止Sql注入等问题; 
支持批量更新,批量删除; 
c.CallableStatement: 
继承自PreparedStatement,支持带参数的SQL操作; 
支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持; 

Statement每次执行sql语句，数据库都要执行sql语句的编译 ， 
最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。 

PreparedStatement是预编译的，使用PreparedStatement有几个好处 
\1. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。 
\2. 安全性好，有效防止Sql注入等问题。 
\3. 对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch； 
\4. 代码的可读性和可维护性。

### 63

![image-20220921092707215](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220921092707215.png)

A选项，静态内部类继承ReentrantLock可重入锁来管理锁，没有用synchronized



```
static` `class` `Segment<K,V> ``extends` `ReentrantLock ``implements` `Serializable {``    ``private` `static` `final` `long` `serialVersionUID = 2249069246763182397L;``    ``final` `float` `loadFactor;``    ``Segment(``float` `lf) { ``this``.loadFactor = lf; }``  ``}
```

B选项，应该是实现了Map接口



```
public` `class` `HashMap<K,V> ``extends` `AbstractMap<K,V>``  ``implements` `Map<K,V>, Cloneable, Serializable
```

C选项，查看源码可以看出返回的是Arrays的私有内部类
而不是ArrayList对象



```
// Arrays.java``private` `static` `class` `ArrayList ``extends` `AbstractList``    ``implements` `RandomAccess, java.io.Serializable``  ``{``    ``private` `static` `final` `long` `serialVersionUID = -2764017481108945198L;``    ``private` `final` `E[] a;``    ``ArrayList(E[] array) {``      ``a = Objects.requireNonNull(array);``    ``}
```

D选项，的确线程不安全，文档上是这么写的

```
日期格式不同步。 建议为每个线程创建单独的格式实例。 ``如果多个线程同时访问格式，则必须在外部进行同步。
```

### 64父类引用指向子类

![image-20220921093148652](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220921093148652.png)

![image-20220921093207813](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220921093207813.png)

也就是是编译的时候会把它当成左边的类型，运行的时候看右边类型的方法体。这个题动物类没有另一个方法，而b调用了，所以编译器会认为b是一个动物类，所以报错。这就是多态的特性吧

### 65重载与重写要求

方法的重载要求：（方法名必须一样， 方法签名必须不同）

  方法名必须一样

  参数表必须不同（数目或者类型不同）

  返回类型、修饰符可以相同也可以不同。

   

方法的重写：         方法的签名必须一样（方法名必须一样，参数保持一致）并且返回类型、访问权限、抛出的异常都有限制

​            返回类型小于等于父类的返回类型

​            子类抛出的异常小于等于父类方法抛出的异常

​            子类方法的访问权限不得小于父类方法的访问权限

### 66 **=**与equal

#### 1.== 和 equals():

(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。

(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。

  2.String对象的两种创建方式:

(1)第一种方式: String str1 = "aaa"; 是在常量池中获取对象("aaa" 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)

(2)第二种方式: String str2 = new String("aaa") ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 "aaa" 象）。

​    System.out.println(str1==str2);//false



#### 3.String类型的常量池比较特殊。它的主要使用方法有两种：

(1)直接使用双引号声明出来的String对象会直接存储在常量池中。
(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。
  String s1 = new String("AAA");
  String s2 = s1.intern();
  String s3 = "AAA";
  System.out.println(s2);//AAA
  System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，

  System.out.println(s2 == s3);//true， s1,s2指向常量池中的”AAA“

#### 4字符串拼接：

  String a = "a";
  String b = "b";
    
  String str1 = "a" + "b";//常量池中的对象
  String str2 = a + b; //在堆上创建的新的对象  
  String str3 = "ab";//常量池中的对象
  System.out.println(str1 == str2);//false
System.out.println(str1 == str3);//true 
  System.out.println(str2 == str3);//false

### 67值传递与引用传递

1、按值传递（传递数值）
 2、按引用传递（传递对象的引用，即数据的地址）

 一、按值传递 call by value
 1、不会改变传递的数值大小

 二、按引用传递 call by reference
 1、不会改变传递的数据的地址
 2、可以改变传递的数据参数内容



### 68



```
public` `static` `String toString(``char` `c) {``  ``return` `String.valueOf(c);``}
```



```
public` `static` `String valueOf(``char` `c) {``  ``char` `data[] = {c};``  ``return` `new` `String(data, ``true``);``}
```

 返回的结果是一样的

只有char变int才会变数字

### 69

final修饰的变量，变量的引用（地址）是不可变得，但是引用的内容是可变的

### 70

链接：https://www.nowcoder.com/questionTerminal/5dbdf7b89d9a4c27908a8c5c1e88c2fe
来源：牛客网



- 静态方法（static修饰）是静态绑定，编译期间根据创建对象时，等号左边的数据类型确定调用父类还是子类的方法。因此不会调用子类Sub的`getType`方法，只会调用父类Super的。    
-    重载是静态绑定，编译时多态，编译期间根据实参的等号左边的数据类型去严格匹配形参的数据类型和个数。   

[复制代码](#)

```
public` `class` `StaticInherit {``  ``public` `static` `void` `main(String[] args) {``    ``Collection<?>[] collections =``        ``{``new` `HashSet<String>(), ``new` `ArrayList<String>(), ``new` `HashMap<String, String>().values()};``    ``System.out.println(``"静态绑定，看编译类型(左边)"``);` `    ``System.out.println(``"----------> 通过对象调用方法 <--------------"``);``    ``System.out.println(``"左边为父类，调用父类"``);``    ``Super subToSuper = ``new` `Sub();``    ``for``(Collection<?> collection: collections) {``      ``System.out.println(subToSuper.getType(collection));``    ``}` `    ``System.out.println(``"-------------------------"``);``    ``System.out.println(``"左边为子类，调用子类"``);``    ``Sub sub = ``new` `Sub();``    ``for``(Collection<?> collection: collections){``      ``System.out.println(sub.getType(collection));``    ``}` `    ``System.out.println(``"----------> 通过类调用方法 <--------------"``);``    ``System.out.println(``"Super调用方法"``);``    ``for``(Collection<?> collection: collections){``      ``System.out.println(Super.getType(collection));``    ``}``    ``System.out.println(``"---------------------"``);``    ``System.out.println(``"Sub调用方法"``);``    ``for``(Collection<?> collection: collections){``      ``System.out.println(Sub.getType(collection));``    ``}` `    ``System.out.println(``"------------> 通过对象调用属性 <-------------"``);``    ``System.out.println(subToSuper.name);``    ``System.out.println(sub.name);``    ``System.out.println(``"------------> 通过类调用属性 <-------------"``);``    ``System.out.println(Super.name);``    ``System.out.println(Sub.name);``  ``}` `  ``abstract` `static` `class` `Super {``    ``static` `String name = ``"Super"``;` `    ``public` `static` `String getType(Collection<?> collection) {``      ``return` `"Super:collection"``;``    ``}``    ``public` `static` `String getType(List<?> list) {``      ``return` `"Super:list"``;``    ``}``    ``public` `String getType(ArrayList<?> list) {``      ``return` `"Super:arrayList"``;``    ``}``    ``public` `static` `String getType(Set<?> set) {``      ``return` `"Super:set"``;``    ``}``    ``public` `String getType(HashSet<?> set) {``      ``return` `"Super:hashSet"``;``    ``}``  ``}` `  ``static` `class` `Sub ``extends` `Super {``    ``static` `String name = ``"Sub"``;` `    ``public` `static` `String getType(Collection<?> collection) {``      ``return` `"Sub"``; }``  ``}``}
```

-    输出结果   

[复制代码](#)

```
静态绑定，看编译类型(左边)``----------> 通过对象调用方法 <--------------``左边为父类，调用父类``Super:collection``Super:collection``Super:collection``-------------------------``左边为子类，调用子类``Sub``Sub``Sub``----------> 通过类调用方法 <--------------``Super调用方法``Super:collection``Super:collection``Super:collection``---------------------``Sub调用方法``Sub``Sub``Sub``------------> 通过对象调用属性 <-------------``Super``Sub``------------> 通过类调用属性 <-------------``Super``Sub
```

### 71java中的集合类型

![img](https://uploadfiles.nowcoder.com/images/20190626/8063197_1561528276822_5E395ABADA193BD98F733540EDD03F5C)

### 72



以下哪些表达式返回为真（）  

```
String a=``"My field1"``;``String b=``"My field1"``;``  ``String c=``new` `String(``"My field1"``);``  ``String d=``new` `String(``"My field1"``);
```

![img](https://uploadfiles.nowcoder.com/images/20220705/920575805_1657016009014/CAE614F3E9571B3551A403845E282016)



==，如果作用的是基本数据类型，则比较的是存储的值是否相同，如果作用引用的数据类型，则比较的是存储的值和对象的地址是否相同； 

  equals只作用于引用型的数据类型，equals方法是用来比较两个对象的引用是否相等

### 73

A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。
 B，CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。
 C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。
 D，Counter不是并发编程的同步器

### 74

（1）基本类型，比如int，double，char都是值传递 

  例： 

  void change(int a) 

  {a++;}                 

​    public static void main(String[] args)  

​    {  

​     int i=1;


​     change(i);


​    }  

   change执行之后i为1，为什么呢？因为执行change(i)时复制了一份i(pie)，然后把复制的i(pie)撇传进去了，这就是值传递，没有影响到原来的i本身。  

   **这里注意，String为值传递，具体原因：记住就行，经常有人用这个考你。**


   （2）对象类型:比如一个pojo，或者是数组对象  

   例：  

  class User 

  { 

​    public int id;


   }


  void change(User user) 

  { 

​    user.id++;


  } 

   public static void main(String[] args)  

​    {  

​      User user = new User();


​     user.id=1;


​     change(user);  

​    }  

   change执行后的user.id不是之前的1而变成了2，为什么呢？因为执行change(user)时是引用传递，直接将user本身的地址传了进去，实际参数都会发生变化。  

   **数组和对象一样，也是引用传递，具体原因：记住就行，经常有人用这个考你。**  

   这个问题引申出来就会出现对象的复制问题

   User a = new User();  

   User b = a;  

   不是新建一个和a一样的User b，而是b和a一起引用User a这个对象

### 75 

instance of 用来判断该对象是否是一个类的实例，一个子类的实例，一个接口的实现类

### 76

synchrozied关键字称作同步，主要用来给方法、代码块加锁，被加锁的代码段，同一时间内多线程同时访问同一对象的加锁方法/代码块时，只能有一个线程执行能执行方法/代码块中的代码，其余线程必须等待当前线程执行完以后才执行该方法/代码块。

volatile关键字1.保证了不同线程对该变量操作的内存可见性.(当一个线程修改了变量,其他使用次变量的线程可以立即知道这一修改)。2.禁止了指令重排序.

Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。

transient关键字 简单地说，就是让某些被修饰的成员属性变量不被序列化。

### 77

接口体现的是一种规范和实现分离的设计哲学，代码编写过程中充分利用接口可以很大程度的降低程序各个模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这一原则，很多软件架构更提倡面向接口编程而不是实现类编程。

接口和抽象类都可以被声明使用

类到底能不能被实例化是初学者很容易犯的错误，抽象类确实有构造方法，但这个构造方法是用来被子类调用的，因为任何子类都必须调用从Object开始的所有父亲的构造方法，才算完成初始化工作。如果抽象类被实例化，就会报错，编译无法通过。而接口里不包含构造器，自然无法被实例化。

### 78

记住接口中的方法都是public abstract类型的，变量都是public static final类型的，既然方法字段都是public类型的，就是为了让所有的类、包使用的，所以自然需要使用public去修饰了。

### 79

后端获取数据，向前端输出的过程中，输出前应该采用信息安全部发布的XSSFilter进行相应编码。

### 80

Java 的屏幕坐标是以像素为单位，容器的左上角被确定为坐标的起点 是左上角，不是左下角

### 81

方法区和堆内存是线程共享的。 程序计数器、虚拟机栈是线程隔离的。

### 82

Socket套接字，就是源端口号和目标端口号的组合 

  服务器端：ServerSocket提供的实例 

   ServerSocket server = new ServerSocket(端口号) 

  客户端，Socket提供的实例 

  Socket soc = new Socket(ip地址，端口号)

### 83

首先分为异常和错误： 

​      错误不用处理，因为也没法处理 

​      异常：分为运行时异常、非运行时异常 

​          运行时异常自己选择是否要 try catch ,也可以自己 throw 

​          非运行时异常就必须得try catch 或者 throws 

### 84执行顺序

初始化静态变量--执行静态代码块--执行main方法

public class Test1 {

    static int cnt = 6;
    
    static {
        cnt += 9;
    }
    
    public static void main(String[] args) {
        System.out.println("cnt =" + cnt);
    }
    
    static {
        cnt /= 3;
    }
    }
\1. static int cnt = 6; 父类静态变量

\2. cnt += 9; （cnt＝15），父类静态代码块1

\3. cnt /=3;（cnt＝5），父类静态代码块2



### 85

**Applet** 是一种在 Web 环境下，运行于客户端的Java程序组件。Applet 必须运行于某个特定的“容器”，这个容器可以是浏览器本身，也可以是通过各种插件，或者包括支持 Applet 的移动设备在内的其他各种程序来运行。与一般的Java应用程序不同，Applet 不是通过 main 方法来运行的。**Applet运行之前，先调用 Init() 方法，然后调用 start() 方法，最后调用 paint() 方法。**

### 86

如果将父类放在前面的话，异常将被父类完全捕获，子类永远不能捕获异常

简单记忆：老将（牛X的）都是最后出马

（ 若 catch 中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面 ）

### 87

**以下** **b** **的值是：** **byte b = (byte)129;**

这题考察的就两个知识点：一、强制转换（主要涉及各个类型占几个字节，这里我只简单说一下byte型占一个字节，也就是8位，int型4个字节，32位）；二、在计算机系统中，数值一律用**补码**来表示（存储）

正数：补码=反码=原码（当然以二进制形式表达）

129 int类型（4个字节）二进制： 00000000 00000000 00000000 10000001

强制转换byte型后，只有一个字节即 10000001（注意这里从二进制角度看，第一位是符号位，即求负数的补码接下来）

只要求出上面原码对应的补码就行了，然后再转换对应的int型数值（因为题干所给的答案都是比较int型）

10000001（原码） 对应的反码为1111 1110

又补码等于反码+1

即1111 1111 该二进制转换int型刚好是-127（1+2+4+8+16+32+64）

普及一下：正数原码，反码，补码相同

负数反码除了符号位不变，其他位取反，补码=反码+1；

### 88 Arraylist扩容

![image-20220925105348248](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220925105348248.png)

### 89

Java中线程实现有两种方式

1、实现Runnable接口，覆盖了run()方法，调用方法, new Thread(new A()).start()，调用线程。

2、继承Thread，并重写run()方法，调用方法，new A().start()  就调用了线程。

### 90位运算符

![image-20220926095232542](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220926095232542.png)

### 91ThreadLoacl

1、ThreadLocal的类声明：

public class ThreadLocal<T>

可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。

2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。

所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立

由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，

变量被彻底封闭在每个访问的线程中。

3、ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本：

 static class ThreadLocalMap {

​    static class Entry extends WeakReference<ThreadLocal> {

​      /** The value associated with this ThreadLocal. */

​      Object value;

​      Entry(ThreadLocal k, Object v) {

​        super(k);

​        value = v;

​      }

​    }

​    /**

​     \* The table, resized as necessary.

​     \* table.length MUST always be a power of two.

​     */

​    private Entry[] table;

}

### 92类型转换

**低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte<char<short<int<long<float<double**

![image-20220928082834146](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220928082834146.png)

### 93

重载  同一个类中   方法名相同，参数列表（参数类型/个数不同 ），与权限修饰符和返回值类型无关

重写  子类重写父类方法   方法名，参数列表（参数类型/个数相同），子类方法访问权限修饰符不小于父类，返回值类型不大于父类 抛出的异常范围不大于父类

### 94

1.类与类之间的关系为继承，只能单继承，但可以多层继承。 

2.类与接口之间的关系为实现，既可以单实现，也可以多实现。 3.接口与接口之间的关系为继承，既可以单继承，也可以多继承。

### 95

有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 1）.隐藏表单域：，非常适合步需要大量数据存储的会话应用。 

2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 

3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP 响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个 Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至 在客户端计算机重启后它仍可以保留其值                           Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话

### 96编译及运行时的异常

![image-20220928083405566](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220928083405566.png)

### 97

![image-20220928085326966](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220928085326966.png)

### 98

Java基本数据类型共有八大类，这八大数据类型又可分为四小类，分别是整数类型（byte/short/int/long）、浮点类型（float、double）、字符类型（char）和布尔类型（boolean），其中并不包括String。

C语言当中的String，Java的String虽然也是char类型的数组char[]实现的，但并不以“\0”结尾。

String类重写了Object类的equals()方法，使用equals()方法可以用于比较两个String是否内容一样。

 char 类型的编码是Unicode 编码。

### 99



ArrayList（D）继承List（B），List（B）继承Collection（A），而Set（C）继承Collection（A）。 

  那么可以说ArrayList（D）是List（B）类型的，也可以说是Collection（A）类型的，但是不能说是Set（C）类型的。

根据英文直译也可以看出，A is-a B:A是一个B，表示A是B的子类，这样A才能称作是一个B，A like-a B:A好像是一个B，表示A实现了B这个接口，A has-a B:A有一个B，表示A是B的父类，这样才能称作A有一个B

### 100

Servlet 与 CGI 的比较 

  和CGI程序一样，Servlet可以响应用户的指令(提交一个FORM等等)，也可以象CGI程序一样，收集用户表单的信息并给予动态反馈(简单的注册信息录入和检查错误)。
 然而，Servlet的机制并不仅仅是这样简单的与用户表单进行交互。传统技术中，动态的网页建立和显示都是通过CGI来实现的，但是，有了Servlet,您可以大胆的放弃所有CGI(perl?php?甚至asp!)，利用Servlet代替CGI,进行程序编写。
   对比一：当用户浏览器发出一个Http/CGI的请求，或者说 ***调用一个CGI程序的时候，服务器端就要新启用一个进程\*** (而且是每次都要调用)，调用CGI程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。
 ***而Servlet充分发挥了服务器端的资源并高效的利用。每次调用Servlet时并不是新启用一个进程\*** ，而是在一个Web服务器的进程敏感词享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。
   对比二：传统的CGI程序，不具备平台无关性特征，系统环境发生变化，CGI程序就要瘫痪，而Servlet具备Java的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。
   对比三：传统技术中，一般大都为二层的系统架构，即Web服务器+数据库服务器，导致网站访问量大的时候，无法克服CGI程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而我们的Servlet有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统"要"一个连接即可，反应速度可想而知。

### 101

使用new关键字来生成对象只是最常用的方式；除此之外，还可以：
1，使用反射创建对象，调用java.lang.Class或者java.lang.reflect.Constructor类的new Instance()实例方法；
2，调用对象的clone()方法（要拷贝的对象需要实现Cloneable接口，并重写clone()方法）；
3，使用反序列化方式，通过让类实现Serializable接口，然后使用new ObjectInputStream().readObject()来创建对象



### 102

in读取文件到编译器上，out从编译器输出到文本文件上

### 103线程安全分类

简单记忆线程安全的集合类： **喂！SHE！  喂是指** **vector，S是指 stack，** **H是指**  **hashtable，E是指：Enumeration**

### 104 取值

**byte：-128~127。直接给个128，编译器会认为是int值，这个时候需要强转成byte。** 

  **boolean：基本数据类型，只有false，true。默认值是false。一旦是包装类Boolean，那默认值是null。**

### 105 ThreadLocal

```
ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递
线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收
在Thread类中有一个Map，用于存储每一个线程的变量的副本。
对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式
```

### 106

getDeclaredField：查找该Class所有声明属性(静态/非静态)，但是他不会去找实现的接口/父类的属性

getField：只查找该类public类型的属性，如果找不到则往上找他的接口、父类，依次往上，直到找到或者已经没有接口/父类

### 107构造函数

构造函数只能被调用，不能被继承。子类默认调用父类无参构造器，若父类没有无参构造器，子类需要用super()调用父类有参构造器，且super()位于子类构造器的第一行，构造函数没有继承这一说

### 108Collection&Map接口

![image-20221001091902476](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20221001091902476.png)

### 109 Switch支持类型

以java8为准，switch支持10种类型  基本类型：byte char short int  对于包装类 ：Byte,Short,Character,Integer  String  enum      2、实际只支持int类型  Java实际只能支持int类型的switch语句，那其他的类型时如何支持的  a、基本类型byte char short       原因：这些基本数字类型可自动向上转为int, 实际还是用的int。  b、基本类型包装类Byte,Short,Character,Integer        原因：java的自动拆箱机制 可看这些对象自动转为基本类型  c、String 类型       原因：实际switch比较的string.hashCode值，它是一个int类型       如何实现的，网上例子很多。此处不表。   d、enum类型       原因 ：实际比较的是enum的ordinal值（表示枚举值的顺序），它也是一个int类型     所以也可以说 switch语句只支持int类型

### 110


**LinkedHashSet**   

  继承于HashSet、又基于 LinkedHashMap 来实现  

  **TreeSet**  

  使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 

   **HashSet**    

   存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得

### 111运行时常量池

**白话讲解:**

  运行时常量池,是jvm内存模型的一种,是内存模型方法区的一部分. 

  那我们先讲讲方法区是个啥:方法区是jvm里线程共享的一部分内存,主要放,**存储已被虚拟机加载的类信息，常量，静态常量，即编译器编译后的代码数据等。****也称为永久代，嗯,就是放一些不会经常改变的东西,和class那个有关.**

  运行时常量池嘛,在方法区的基础上存放编译期生成的各种字面量(基本类型赋值方式)和符号引用(引用类型)，比如字符串常量池,整形常量池啥的,就是在这里放着的,

 运行时常量池对于Class文件常量池的一个特征是具备动态性，Java语言不要求常量一定是在编译期才产生，即并非预置入Class文件中的常量池的内容可以才能进入方法区运行时常量池，运行期也可以将新的常量放入池中，比如String的intern()方法。当常量池无法在申请内存时会抛出OutOfMethodError异常。

### 112 OOP与AOP

AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。
AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象 ，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。
核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉， AOP只是OOP的补充，无替代关系。

### 113 

**1. static块只执行一次，在JVM加载类的时候。**

**2. 构造块在没有实例化对象的时候执行。**

### 114流

按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。

- 节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.
- 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。

**JAVA常用的节点流：**

- 文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。
- 字符串 StringReader StringWriter 对字符串进行处理的节点流。
- 数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。
- 管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。

**常用处理流（关闭处理流使用关闭里面的节点流）**

- 缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。

- 转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
- 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.

流的关闭顺序

1. 一般情况下是：先打开的后关闭，后打开的先关闭
2. 另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b
3. 可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。

### 115

定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0

局部变量是定义在方法中的变量，必须要进行初始化，否则不同通过编译

被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量

被final修饰发变量是常量

### 116request

request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。

### 117

**父类对子类构造方法的影响：**

如果**父类拥有无****参构造方法**（无论隐式的还是显式的）且子类中的构造方法又没有明确指定调用父类的哪个构造方法，则子类中没有调用该子类其它构造方法的构造方法使用super()隐式调用父类的无参构造方法，如下代码：![img](https://uploadfiles.nowcoder.com/images/20190202/4628511_1549080430042_E20F465A4CCD3A90F745EC00606D13F4)![img](https://uploadfiles.nowcoder.com/images/20190202/4628511_1549080437172_81A6A5EAFA7FFD33754C1A362297C80D)

如果**父类没有无参构造方法**（无论隐式的还是显式的），则要求子类构造方法必须直接或间接指定调用父类哪个构造方法并且放在有效代码第一行，如下代码：![img](https://uploadfiles.nowcoder.com/images/20190202/4628511_1549080372614_59DABD8BD37DBC5DBECD6B450F6BEE7A)

![img](https://uploadfiles.nowcoder.com/images/20190202/4628511_1549080382719_817497495FBD180E6C5303298D996469)

**一句话：子类必须调用父类的构造方法。**

### 118

被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量

### 119

this()和super()都是构造器，this()调用本类构造器，super()调用父类构造器

### 120

package为第一行，其次再是import;   java.util.*，只能读取其目录下的类，不能读取其子目录下的类。因为其根目录和子目录下可能有同名类. 举个栗子： a.b.j 和a.b.c.j 调用j时不能确定是哪个j

### 121

在执行URL u =new URL("http://www.123.com");这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。

![img](https://uploadfiles.nowcoder.com/images/20180918/1319299_1537232948841_B304403EFD76FFAA17EF2B8061A20191)

### 122 volatile 

链接：https://www.nowcoder.com/questionTerminal/81888b413fae42348429b845242c4edd
来源：牛客网



关于volatile:有序性,可见性, 

  


  volatile用与修饰实例变量和类变量,是一种维护线程安全的手段,作用是实现共享资源的可见性  

  


####   可见性的意思: 

  进程中的内存分为工作内存(线程内存)和主内存,普通变量的读写依赖于当前工作内存,直到线程结束,才会把值更新到主内存,  

  


  当有多线程存在时,就无法保证数据的真实性(可见性),其他线程读到的数据可能旧的.  

  


  volatile修饰的变量每次获取的值都是从主内存中直接读的,写完之后也会直接更新到主内存,实现方式以**机器指令(硬编码)**的方式实现  

  


  jkd之后的版本在设计线程安全上都是基于volition和显示锁的方式,很少有用同步块和同步方法的方式,因为同步块方法的来讲,线程以串行的方式经过,效率太低.容易阻塞,而且保持原子性,只要线程进去就无法被打断,而volatile不会阻塞.不保证原子性.  

  


####   有序性的意思: 

  jvm和处理器在编译Java代码的时候,出于性能考虑,会对原有的代码进行重排序,(也就是指令重排)我们写好的代码都有顺序,在我们执行的时候由ＪＶＭ内存模型里的程序计数器标记的,保证线程安全的时候，一般都会禁止指令重排即保证有序性．说是并发环境下指令重排会有很多问题．  

  


  但是volatile和synchronized的有序是不同的:  

  


  volatile关键字禁止JVM编译器已及处理器对其进行重排序,  

  


  synchronized保证顺序性是串行化的结果，但同步块里的语句是会发生指令从排。  

  


**深入volatile关键字的介绍
 1）被volatile关键字修饰的实例变量或者类变量具备两层语义：
         \**保证了不同线程之间对共享变量的可见性，\**          \**禁止对volatile变量进行重排序。\**      2）volatile和synchronized区别
         \**使用上区别：\****      

1. ​    **volatile关键字只能用来修饰实例变量或者类变量，不能修饰方法已及方法参数和局部变量和常量。**      
2. ​    **synchronized关键字不能用来修饰变量，只能用于修饰方法和语句块。**      
3. ​    **volatile修饰的变量可以为空，同步块的monitor不能为空。**     

​         ***\*对原子性的保证\****      

1. ​    **volatile无法保证原子性**      
2. ​    **synchronizde能够保证。因为无法被中途打断。**     

​         ***\*对可见性的保证\****      

1. ​    **都可以实现共享资源的可见性，但是实现的机制不同，synchronized借助于JVM指令monitor enter 和monitor exit ，通过排他的机制使线程串行通过同步块，在monitor退出后所共享的内存会被刷新到主内存中。volatile使用机器指令(硬编码)的方式，“lock”迫使其他线程工作内存中的数据失效，不得不主内存继续加载。**     

​         ***\*对有序性的保证\****      

1. ​    **volatile关键字禁止JVM编译器已及处理器对其进行重排序，能够保证有序性。**      
2. ​    **synchronized保证顺序性是串行化的结果，但同步块里的语句是会发生指令从排。**     

​         ***\*其他：\****      

1. ​    **volatile不会使线程陷入阻塞**      
2. ​    **synchronized会会使线程进入阻塞。**     

### 123 重载与重写

面试很喜欢问的：   首先，重载和重写都是多态的一种体现方式。重载是编译期间的活动，重写是运行期间的活动。   其次，重载是在一个类中定义相同的名字的方法，方法的参数列表或者类型要互相不同，但是返回值类型不作为是否重载的标准，可以修改可见性；   重写是不同的，要求子类重写基类的方法时要与父类方法具有相同的参数类型和返回值，可见性需要大于等于基类的方法   ****

方法重写的注意事项： 

  构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同 

  private修饰的成员方法不能被重写 

  static修饰的方法不能被重写 

  final修饰的方法不能被重写 

  当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法

### 124

ResultSet默认的第一列的索引是1

### 125反射

JAVA的反射机制主要提供的功能有：
     1、在运行时判断任意一个对象所属的类；
     2、在运行时构造任意一个类的对象；
     3、在运行时判断任意一个类所具有的成员变量和方法；
     4、在运行时调用任意一个对象的方法；
     5、生成动态***；

![image-20221004092854591](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20221004092854591.png)

### 126 IO

![image-20221004095608871](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20221004095608871.png)

### 127

在一个程序当中代码段访问了同一个对象从单独的并发的线程当中，那么这个代码段叫”临界区” 
*怎么解决呢：使用同步的机制对临界区进行保护* 

**同步的两种方式**：同步块和同步方法 
对于同步来说都是使用synchronized方法

  每一个对象都有一个  **监视器**  ，或者叫做  **锁**  。

  java用  监视器  机制实现了进程之间的异步执行

**监视器** **”monitor”** 是操作系统实现同步的重要基础概念，同样它也用在JAVA的线程同步中， 在语法的表现就是synchronized  。

### 128jvm



#### 一、 程序计数器 

  一块较小的内存空间，可以看作是当前线程所执行的字节码的**信号指示器**。在虚拟机的概念模型里面，字节码解释器工作时就是通过改变**这个计数器的值**来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器完成。 

  

  由于Java虚拟机的多线程是通过**线程轮流切换**、**分配处理器执行时间**的方式来实现，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，**为了线程切换后能恢复到正常的执行位置**，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 

  

  如果线程正在执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，计数器值应为空（Undefined）。 
 

####   二、 Java虚拟机栈 

  与程序计数器一样，它也是线程私有的。 

  

  Java虚拟机栈描述的是**Java方法执行的线程内存模型**： 

  每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**用于存储**局部变量表**、**操作数栈**、**动态连接**、**方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 

  

  什么是局部变量表： 

  存放了编译器可知的各种Java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，她并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 


这些数据类型在局部变量表中的存储空间以**局部变量槽**（Slot）来表示，其中64位长度的long、double类型的数据会占用**两个**变量槽，其余的只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

####   三、 Java堆 

  Java堆（Java Heap）虚拟机管理的内存中**最大**的一块。Java堆是被**所有线程共享**的一块内存区域，在虚拟机**启动时创建**。 

  

  此内存的唯一目的就是：**存放对象实例。** 

  **
**  

  **因此，**Java堆也是**垃圾收集器**管理的内存区域。 

  

####   四、 方法区 

  与Java堆一样，方法区是**各个线程共享**的内存区域，用于存储已被虚拟机加载的**类型信息**、**常量**、**静态变量**、即时编译器编译后的**代码缓存**等数据。 

![image-20221004101137458](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20221004101137458.png)
