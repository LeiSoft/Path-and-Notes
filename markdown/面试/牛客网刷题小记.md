# 牛客网刷题小记

## MySQL
### 1.查询语句执行顺序

（8）Select
（9）distinct 字段名1,字段名2，
（6）[fun(字段名)]  
（1）from 表1
（3）<join类型>join 表2 
（2）on <join条件> 
（4）where <where条件> 
（5）group by <字段> 
（7）having <having条件> 
（10）order by <排序字段> 
（11）limit <起始偏移量,行数>

### 2.使用聚合函数，则判断条件使用having

where---过滤指定的行
having--过滤分组，与group by连用
返回订单数量总和不小于100:having sum(quantity)>= 100

### 3.返回同一表中的字段及字段别名，group、order同时使用

返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines对结果进行升序排序。
SELECT 
    order_num,
    COUNT(order_num) order_lines
FROM
    OrderItems
GROUP BY
    order_num
ORDER BY
    order_lines;

### 4.

可以使用ORDER BY，GROUP BY和HAVING子句中的列别名来引用该列。
不能在WHERE子句中使用列别名。原因是当MySQL评估求值WHERE子句时，SELECT子句中指定的列的值可能尚未确定。

### 5.MYSQL中何时使用group by

1）当聚合列和非聚合列出现在一起时必须使用group by,如:
#emp为员工表,deptno为部门编号字段,sal为工资字段
SELECT deptno,MAX(sal),AVG(sal) FROM emp
GROUP BY deptno #按照部门分组

当使用group by时,应使用非聚合列为分组依据.

2）什么是聚合列
聚合列是指根据需求算出结果的列,
常使用的聚合列函数有
count(求个数),
sum(求合),
max(求最大值),
min(求最小值),
avg(求平均数)

#emp为员工表,sal为工资字段

#求emp字段一共有几条数据
select count(*) from emp
#求员工工资总和
select sum(sal) from emp
#求员工最高工资
select max(sal) from emp
#求员工最低工资
select min(sal) from emp
#求员工平均 工资
select avg(sal) from emp

3）having条件查询
当使用group by进行分组时,想要使用条件查询,必须使用having,而不是where

#查询平均工资小于8000的部门
#emp为员工表,deptno为部门编号字段,sal为工资字段
select deptno, AVG(sal) from emp
group by deptno #按部门分组
having AVG(sal)<8000 #查询条件,类似where,但是group by中只能使用having
将两个 SELECT 语句结合起来（一）#
发表于 04-28 17:08
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;

### 6.union

union--连接表，对行操作。
union--将两个表做行拼接，同时自动删除重复的行。
union all---将两个表做行拼接，保留重复的行
【问题】
    将两个 SELECT 语句结合起来，以便从 OrderItems表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。
    
结合多个select结果采用union或者union all，union会自动去除重复的元组(行);
根据题意推断，拼接多个查询结果集时需要去重，因此采用union；
需要以BNBG开头，所以需要用模糊查询；
最后排序使用order by;
select *  from OrderItems where quantity=100
union
select * from OrderItems where prod_id like "BNBG%"
order by prod_id;

使用union组合查询时，只能使用一条order by字句，他必须位于最后一条select语句之后，因为对于结果集不存在对于一部分数据进行排序，而另一部分用另一种排序规则的情况。 

## java
### 1.HttpServlet容器响应Web客户请求流程如下：

1）Web客户向Servlet容器发出Http请求；

2）Servlet容器解析Web客户的Http请求；

3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；

4）Servlet容器创建一个HttpResponse对象；

5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；

6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；

7）HttpServlet调用HttpResponse的有关方法，生成响应数据；

8）Servlet容器把HttpServlet的响应结果传给Web客户。

### 2.try块中放置可能引发异常的代码 故不可被省略

Jdk1.7中新增了多个catch块的功能，用以捕获多异常， 捕获顺序为先小后大
finally块用作回收无法被JVM回收的物理资源 例如数据库链接 网络链接等 Jdk1.7中虽增强了try()的功能，使得其中的代码在程序执行完毕后自动关闭代码 相当与隐含finally块
catch块用作捕获异常
总结
异常处理语法结构中只有try块是必须的，但不能只有try块，1.7中的增强try除外 因为其中的try()已经隐含了finally了 
通常一个类实现序列化方式是实现序列化接口 Serializable

### 3.序列化

序列化的作用：把数据长久的保存在磁盘中，磁盘和内存是不同的，内存一般在程序运行时占用，数据保存周期短，随程序结束而结束，磁盘可以长久保存数据

transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，就这个作用------在已序列化的类中使变量不序列化

### 4.super

特殊变量super，提供了对父类的访问。

可以使用super访问父类被子类隐藏的变量或覆盖的方法。

每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

构造是不能被继承的。

### 5.规范

1、项目名全部小写.
2、包名全部小写.
3、类名首字母大写,其余组成词首字母依次大写.
4、变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写.
5、常量名全部大写.
6、所有命名规则必须遵循以下规则 :

名称只能由字母、数字、下划线、$符号组成.
不能以数字开头.
名称不能使用Java中的关键字.
坚决不允许出现中文及拼音命名.

### 5.public,protected,private,default详解

![image-20220908095551242](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220908095551242.png)

public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不
　　　　　仅可以跨类访问，而且允许跨包（package）访问。
[private](https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020): Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以
　　　　　及方法只能被该类的对象访问，其[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)不能访问，更不能允许跨包访问。
protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、
　　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。
default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访
　　　　　问。



### 6.Java数据库连接库JDBC用到哪种设计模式?

**JDBC使用的是桥接模式**

**定义:将抽象部分与它的实现部分分离,使它们都可以独立的变化**

**意图:将抽象与实现解耦**



### 7.

在Java中数据域和方法都必须属于某一个对象。不能单独存在，没有C++中的全局变量和方法一说。对象必须属于某一个类。**

对象中可以什么也没有**

数据域可以是基本数据类型，也可以是引用类型。**

### 8.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）

```
this(x)
```

### 9.关于cookie和session

  程序一般都是在用户做log off的时候发个指令去删除session，然而浏览器从来不会主动在关闭之前通知服务器它将要被关闭，因此服务器根本不会有机会知道浏览器已经关闭。服务器会一直保留这个会话对象直到它处于非活动状态超过设定的间隔为止。 
   大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接到服务器时也就无法找到原来的session。 如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求报头，把原来的session id发送到服务器，则再次打开浏览器仍然能够找到原来的session。 
   恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为session设置了一个失效时间，当距离客户上一次使用session的时间超过了这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 
   **由此我们可以得出如下结论：** 
   关闭浏览器，只会是浏览器端内存里的session cookie消失，但不会使保存在服务器端的session对象消失，同样也不会使已经保存到硬盘上的持久化cookie消失。



### 10.整数相除之后还是整数，会丢失掉小数部分的数值。

### 11.HashMap底层是数组+链表+红黑树（JDK1.8）来实现的，根据key的hash值查找对应的位桶。

1.当前索引数组为空，则将键值对以链表形式插入。

2.当前索引数组已经存在，则判断当前链表是红黑树还时链表，然后插入。如果是链表插入到最后一个，判断长度是否大于8，大于8将链表转成红黑树。

所以应该是**拉链法**解决冲突。

### 12.jvm

![image-20220910082223873](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082223873.png)



大多数 JVM    将内存区域划分为 **Method    Area（Non-Heap）（方法区）** ,**Heap（堆）** , **Program    Counter Register（程序计数器）** ,  **VM Stack（虚拟机栈，也有翻译成JAVA    方法栈的）,Native Method    Stack** （ **本地方法栈** ），其中**Method Area** 和     ***\*Heap\**** 是线程共享的     ***\*，VM \*\*Stack，Native Method Stack 和\*\*Program          Counter Register\*\*\*\*\****       是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。 

  首先我们熟悉一下一个一般性的  Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class  为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM  通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？ 

​    概括地说来，JVM初始运行的时候都会分配好 **Method  Area（方法区）** 和**Heap（堆）** ，而JVM    每遇到一个线程，就为其分配一个 **Program Counter    Register（程序计数器）** ,  **VM Stack（虚拟机栈）和Native Method  Stack （本地方法栈），** 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。

即，方法区用于存储JVM加载的类信息以及类相关的东西，比如类变量、常量等，是线程隔离的，但是编译器编译后的代码等数据，是线程共享的

![image-20220910082609831](D:\HOLY\路线与笔记\markdown\学习小记\assets\image-20220910082609831.png)

### 13.

java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？

```
1 4 8 2 4 8 1
```

### 14.

成员变量与局部变量的区别 1、在类中的位置不同 成员变量：在类中方法外面 局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中） 2、在内存中的位置不同，可以看看Java程序内存的简单分析 成员变量：在堆中（方法区中的静态区） 局部变量：在栈中 3、生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失 4、初始值 成员变量：有默认初始值 局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized）

### 15.Java 中堆和栈有什么区别？

  JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

        栈：在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
    
        堆：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。



### 16.接口无构造函数，抽象类不允许多继承

抽象类可以有构造函数，毕竟是类。 但是不能实例化。 1.8加入了default和静态方法，可以有方法体

### 17.构造方法的作用是初始化成员变量

### 18.

java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。

### 19.

接口和抽象类的区别：
 1.接口的方法默认为public abstract ,接口中的变量默认为public static final，在java8之前所有的方法不能有实现
 抽象类中可以有非抽象方法
 2.一个类可以实现多个接口，但只能继承一个抽象类
 3.一个类实现接口，要实现该接口的所有抽象方法。
 4.接口不能被实例化，但可以声明，但是必须引用一个实现该接口的对象。
 抽象类可以有构造方法，但是不能被直接通过new进行实例化。但可以通过子类继承，实例化子类的时候抽象类也会被实例化。
 这其实用到了多态，向上转型。父类引用指向子类对象。
 5.从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。



### 20.jsp

给定includel.isp文件代码片段，如下：
   <% pageContext.setAttribute(“User”,”HAHA”);%>
  ______ // 此处填写代码
   给定include2.jsp文件代码片段如下：
   <%=pageContext.getAttribute(“User”)%>
   要求运行include1.jsp时，浏览器上输出：HAHA
                                        

- ```
  &lt;jsp:include page=&rdquo;include2.jsp&rdquo; flash=&rdquo;true&rdquo;&gt;
  ```

- ```
  &lt;%@include file=&rdquo;include2.jsp&rdquo;%&gt;
  ```

- ```
  &lt;jsp:forward page=&rdquo;include2.jsp&rdquo;&gt;
  ```

- ```
  &lt;% response.sendRedirect(&ldquo;include2.jsp&rdquo;); %&gt;
  ```

A选项使用了jsp中动作标签的包含标签，这里是动态包含。原理是包含与被包含的页面单独翻译成不同的java文件，然后运行时合并在一起。因为是存在域中的数据，故刚开始就直接翻译数据还不存在，因此浏览器上不能显示出HAHA。 

  B选项使用了jsp三大指令中的包含指令，这里是静态包含。原理是直接把包含与被包含页面的内容先合并在一起，然后翻译成一个java源文件，最后编译执行。故可以在浏览器上显示出HAHA。 

  C和D选项分别使用了跳转和重定向，我们知道jsp中有四个域对象，从小到大分别为： 

- ​    page域：在同一个jsp页面中数据有效      
- ​    request域：在同一个请求中数据有效      
- ​    session域：在用一个会话中数据有效      
- ​    application域：在同一个网站中数据有效     

 题中使用的是page域对象：pageContext，而C选项应该使用request域对象：HttpServletRequest，而D选项应该至少使用session域对象：HttpSession（如果处于同一会话中）。



### 21.super

1、子类构造函数调用父类构造函数用super 2、子类重写父类方法后，若想调用父类中被重写的方法，用super 3、未被重写的方法可以直接调用。

### 22.泛型只是提高了数据传输安全性，并没有改变程序运行的性能

### 23.

1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。

(不管你try中有没有return，finally中的代码一定会执行。当try中有return，但是finally中没有，则finally中的代码在try中return执行前执行；当两者中均有return，那么先执行finally中return之前的代码，然后执行try中return，最后执行finally中的return!!!)

### 24.

![image-20220912142132565](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220912142132565.png)

### 25.

类变量在不设置初始值时，会进行默认赋值，而局部变量（方法中的变量）必须进行初始化，不会进行默认的赋值，Java中基本数据类型默认值为： 　　short: 0 　　int: 0 　　long:0 　　float: 0.0 　　double: 0.0 　　char:0 　　String:null 　　Java中对象引用默认值为null

### 26.关于静态方法

静态只能调用静态，非静态既可以调用静态也可以非静态



### 27.

Thread类中start()和run()方法的使用的不同。start()方法真正启动线程，让线程处于就绪状态，一旦得到时间片，则会调用线程的run()方法进行到运行状态。而run()方法只是一个普通方法调用而已，可以直接理解为调用方法A()。

类似的考题还有wait()和sleep()方法的比较。

① 这两个方法来自 不同的类 分别是，sleep来自Thread类，和wait来自Object类。



② 锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。

③ 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

  synchronized(x){ 
   x.notify() 
   //或者wait() 

  }



### 28.

在方法中改变了对象的引用，指的是仅仅改变引用而已，对象还是那个对象。

**就相当于你银行卡丢了，你重新补办换了一张卡，变的是银行卡，而你卡里的钱一分都没少。**



> 1.Java中没有指针，所以也没有引用传递了，仅仅有值传递。不过，可以通过对象的方式来实现引用传递。类似java没有多继承，但可以用多次implements接口实现多继承的功能。
>
> 2.在Java应用程序中永远不会传递对象，而只**传递对象的引用**。因此是按**引用传递对象**。但重要的是要区分参数是如何传递的。
>
> 3.Java应用程序**按引用传递对象**这一事实并不意味着 Java 应用程序按引用传递参数。参数可以是对象引用，而 Java应用程序是**按值传递对象引用的。**
>
> 4.Java应用程序中的变量可以为以下两种类型之一：引用类型或基本类型。当作为参数传递给一个方法时，处理这两种类型的方式是相同的。**两种类型都是按值传递的，**没有一种按引用传递。

```
链接：https://www.nowcoder.com/questionTerminal/72096d298bd344168441361f9c16659c
来源：牛客网

解析: 注意!Java中方法的参数传递都是值传递
A. 在方法中，修改一个基础类型的参数不会影响原始参数值
1
2
3
4
5
6
7
8
9
10
11
public static void main(String []args){
    int i = 5;   
    func(i);
    System.out.println(i);
}
static void func(int j){
    j = 10;
}
 
//输出结果
5
在主方法调用func(int j) 时 , 参数i是实际参数 , 值为5 , 参数j是形式参数 , 值是i给的 , 也是5 , i和j没有任何关系 , 是两个独立的参数 , 所以修改j的值时与i没有关系 , 仍然输出5。

B. 在方法中，改变一个对象参数的引用不会影响到原始引用
1
2
3
4
5
6
7
8
9
10
11
12
13
public static void main(String []args){
    User rabbiter = new User();
    rabbiter.setName("rabbiter");
    func(rabbiter);
    System.out.println(rabbiter.getName());
}
static void func(User user){
    user = new User();
    user.setName("zhangsan");
}
 
//输出结果
rabbiter
在主方法调用func(User user) 时 , 对象rabbiter保存的是一个地址值 , 本质上就是把rabbiter的地址值给了形参user , 所以此时实参rabbiter和形参user指向在堆中的同一个对象 , 他们的地址值相同 , 只是指向的对象一致 , 所以并不违反值传递的理论。
此时 , 如果修改形参user , new一个新的对象并让user指向它 , 修改的只是形参保存的地址 , 与实参rabbiter无关 , rabbiter指向的对象仍然是之前的那个对象。

C. 在方法中，修改一个对象的属性会影响原始对象参数
1
2
3
4
5
6
7
8
9
10
11
12
public static void main(String []args){
    User rabbiter = new User();
    rabbiter.setName("rabbiter");
    func(rabbiter);
    System.out.println(rabbiter.getName());
}
static void func(User user){
    user.setName("zhangsan");
}
 
//输出结果
zhangsan
在主方法调用func(User user) 时 , 对象rabbiter保存的是一个地址值 , 本质上就是把rabbiter的地址值给了形参user , 所以此时实参rabbiter和形参user指向在堆中的同一个对象 , 他们的地址值相同 , 指向的对象一致 , 所以并不违反值传递的理论。
那么user对其指向的对象的属性name进行修改 , rabbiter指向的对象的name属性也就被修改了。

D. 在方法中，修改集合和Maps的元素不会影响原始集合参数
集合和Maps都是对象 , 所以此项跟C选项的解析一致。
```



### 29.

![image-20220913101121668](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220913101121668.png)



### 30



Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.

### 31

JAVA语言中定义了8种基本的数据类型，来保存变量。JAVA要求程序中的每一个变量都规定自己的类型。正因为如此，JAVA属于强类型语言，从而不同于JavaScript这样的弱类型脚本语言。
 下面我们来看看这8种类型： 
byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。
short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。
int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。
long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。
float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。
double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。
boolean：只有true和false两个取值。
char：16位，存储Unicode码，用单引号赋值。
注：一个字节=8位。
所以，整型数据类型中，需要内存空间最多的是long。

### 32

数据类型转换，遵循一个原则：范围小的转到范围大的自动进行转换，范围大的转为范围小的要进行强制类型转换

> 自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下： 
>  低 ---------------------------------------------> 高 
>  byte,short,char-> int -> long -> float -> double
>  其中虽然float占4个字节，long占8个字节，因为底层的实现方式不同，float大于long

### 33抽象类和接口

***\*jdk1.8之前\****  

  ***\*接口\****  

  1.多实现  

  2.变量类型默认且只能为为public static final  

  3.函数类型默认且只能为public，只能有public类型的静态成员函数  

  4.非静态成员函数没有方法体，静态成员函数有方法体  

  5.子类必须实现所有接口函数  

  6.可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数  

  7.没有构造器  

   

  ***\*抽象类\****  

  1.单继承  

  2.变量类型不限（静态变量+非静态变量）  

  3.函数类型不限（静态函数+非静态函数）  

  4.非静态函数包含没有方法体的抽象函数. 有方法体的普通函数  

  5.子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法  

  6.可以有main方法；不可以new一个抽象类  

  7.可以有构造器  



​    接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。另外，接口和抽象类在方法上有区别：  

1.抽象类可以有构造方法，接口中不能有构造方法。 

2.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

3.抽象类中可以有普通成员变量，接口中没有普通成员变量 

\4. 抽象类中的抽象方法的访问类型可以是public，protected和默认类型

\5. 抽象类中可以包含静态方法，接口中不能包含静态方法

\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型

\7. 一个类可以实现多个接口，但只能继承一个抽象类。二者在应用方面也有一定的区别：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。

  ***\*Jdk1.8\****  

  ***\*接口中可以有default、static类型的方法，实现类可以选择实现该方法\****  

  ***\*意义：\****默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。另一个优势为该方法是可选的，子类可以根据不同的需求Override或默认实现。

### 34编码

1.不同的编码格式，字符所占用的字节数是不一样的。如GBK中每个中文占用2个字节，UTF-8中则是变长编码，可能占用3个字节或者4个字节。因此A不正确。 

  2.不同的编码方式之间是可以转换的，如果数据库GBK编码，页面上可以使用任意支持汉字编码的编码方式显示都可以，只要在向页面传输的数据过程中进行编码的转换即可。如：数据库是GBK，页面上是UTF-8,那么可以这样转换：实例代码以java语法编写 

[复制代码](#)

```
byte``[] bytesGBK = readContentFromDatabase(); ``// 从数据库读取的字符数据，GBK编码``String str = ``new` `String(bytesGBK, Charset.forName(``"GBK"``)); ``// GBK编码转换成字符串``// 在向页面传输时，将字符串转换成UTF-8编码的数据流``Writer out = getResponseWriter();``response.setContentType(``"text/plain;charset=utf-8"``); ``// 指定内容的编码格式是UTF-8``out.write(str.getByte(``"UTF-8"``)); ``// 写入UTF-8数据流
```

  3.Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符。

  4.ResourceBundle能够按Local的不同，优先读取对应后缀的properties文件，这个是java中自带的。使用的地方很多。

### 35.Hashtable与HashMap

**Hashtable**：

（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。

（2）Hashtable 的函数都是同步的，这意味着它是**线程安全**的。它的key、value都不可以为null。

（3）HashTable直接使用对象的hashCode。

**HashMap：**

（1）由**数组+链表**组成的，基于**哈希表的Map**实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。

（3）HashMap重新计算hash值

**Hashtable,HashMap,Properties**继承关系如下：

```
public` `class` `Hashtable<K,V> ``extends` `Dictionary<K,V>``  ``implements` `Map<K,V>, Cloneable, java.io.Serializable` `public` `class` `HashMap<K,V>``extends` `AbstractMap<K,V> ``implements` `Map<K,V>, Cloneable, Serializable
```

[复制代码](https://www.nowcoder.com/test/question/done?tid=61320447&qid=57787#)

```
java.lang.Objecct`` ``java.util.Dictionary<K,V>``  ``java.util.Hashtable<Object,Object>``   ``java.util.Properties 
```



### 36重载

重载是Java多态性（在一个类中）的一种表现方式，要注意以下几点：

  1.参数列表不同。包括参数个数、参数类型、参数顺序等的不同；

  2.不能通过方法的访问权限、返回值类型和抛出的异常类型来判断重载；

  3.对于继承来说，如果父类方法的访问权限为private，那么就不能在子类对其重载；如果子类也定义了一个同名的函数，只是一个新方法，并不是重载方法。

### 37&运算

&运算符：两个数都转为二进制，然后从两个数的最高位进行与运算，两个都为真（1），结果才为真（1），否则为假（0）

13：01101
17：10001
结果：00001，既为1



### 38包装类与基本数据类型

基本类型存储在栈里，包装类型存储在堆里。因为栈的效率更高，所以保留了基本类型

```
long和double都占了64位（64bit）的存储空间
```

默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f 

基本数据类型是没有静态方法的，但是基本数据类型的包装类却有

### 39final与abstract

final修饰类时，此类**不能被继承**，但是**可以创建对象**。如包装类（Double、Float等等），String类也是。（所以B错误）

顺便补充一下final修饰方法和属性时的细节：

1. final修饰方法时，子类不能重写该方法； 
2. final修饰不了构造方法； 
3. final修饰属性时，此属性不能被更改，并且必须被赋值。 

abstract修饰类时，表示抽象类。该类**不能被实例化**，即不能创建对象。一般来说，创建抽象类，需要子类来实现抽象方法，所以可以被继承。（所以A正确）
正因为抽象类需要子类来实现，所以与final修饰的类（不能被继承）相违背（所以C正确）。
抽象类不一定要包含abstract方法，但是一旦类包含了abstract方法，则这个类必须声明为abstract（所以D正确）

### 40基本类型与包装类比较

![image-20220915092811449](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915092811449.png)

### 41局部变量与静态变量

![image-20220915092949186](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915092949186.png)

```
a=11 t.a=2
```





### 42Java中的异常分类:  

 可分为:   
 RuntimeException: 
 运行时异常(战之过,程序员的过错),也叫做unchecked Exception, 非编译期异常(编译器检查不出来,只有运行时才能显现出来的异常,叫做非编译异常,或者运行时异常,一般是由于程序员逻辑错误引起的,如空指针异常,数组越界异常等,所以称之为战之过)   

 Exception中除了RuntimeException之外的所有异常,比如IOException,SQLException等    
 非运行时异常(非战之过),也叫做检查异常(check Exception) ,编译异常(编译期可以检查出来的异常,不需要运行就可以检测到的异常,比如IOException,SQLException,等预期之内的异常,因为可以预料到,因此是必须检查的异常,所以,也叫做check Exception)  

 常见的,IOException,SQLException,等所有继承与Exception,但是不继承与RuntimeException的,都属于非运行时异常,是必须在编写程序的时候就要throw的  
 所有继承与RuntimeException的,都是程序员逻辑错误引起的异常,比如空指针异常等,是unchecked Exception  

![image-20220915093357505](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220915093357505.png)

### 43



单例的目的是保证某个类仅有一个实例。当有某些类创建对象内存开销较大时可以考虑使用该模式。**单例模式又分为 饿汉式 和 懒汉式** 。下面分别说明： 

  1.饿汉式。顾名思义，该模式在类被加载时就会实例化一个对象。具体代码如下： 

  public class Person {
   //饿汉式单例
   private static Person person = new Person();
   private Person(){}

   public static Person getInstance(){
   return person;
   }
 }
 该模式能简单快速的创建一个单例对象，而且是**线程安全的(只在类加载时才会初始化，以后都不会)**。但它有一个缺点，就是不管你要不要都会直接创建一个对象，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单)

### 43

关于抽象类

JDK 1.8以前，抽象类的方法默认访问权限为protected

JDK 1.8时，抽象类的方法默认访问权限变为default

关于接口

JDK 1.8以前，接口中的方法必须是public的

JDK 1.8时，接口中的方法可以是public的，也可以是default的

JDK 1.9时，接口中的方法可以是private的

### 44

抽象类和接口的区别:

\1. 抽象类可以有构造方法，接口中不能有构造方法。

\2. 抽象类中可以有普通成员变量，接口中没有普通成员变量。

\3. 抽象类中可以包含非抽象普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。

\4. 抽象类中的抽象方法的访问权限可以是 public、protected 和默认类型，接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。

\5. 抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能不包含静态方法，JDK1.8 以后可以包含。

\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的，并且默认即为 public static final 类型。

\7. 一个类可以实现多个接口，用逗号隔开，但只能继承一个抽象类，接口不可以实现接口，但可以继承接口，并且可以继承多个接口，用逗号隔开。

```
如果是java 7，接口中可以包含的类容有：
1.常量
2.抽象方法

如果是java 8，还可以额外包含：
3.默认方法
4.静态方法

如果是java 9，还可以额外包含有：
5.私有方法
```

### 45取反公式

负数的补码 = 原码取反 + 1，即：

-n = ~n + 1    →  ~n = -n -1   

~j：~10 =  - 10 - 1 = -11

i + j = 5 + -11 = -6 

### 46

- ```
  Java网络编程API建立在Socket基础之上
  ```

- ```
  Java网络接口支持IP以上的所有高层协议
  ```

### 47序列化

- 序列化： **将Java对象或数据结构通过序列化机制转换成二进制字节流传输到网络其他节点或存储介质上。**
- 反序列化： **将网络或存储介质中的二进制字节流通过反序列化机制将其转换成Java对象或数据结构。**



 使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.

​    声明为static和transient类型的成员数据不能被串行化。因为static代表类的状态， transient代表对象的临时数据。

### 48



HashMap可以插入null的key或value，插入的时候，检查是否已经存在相同的key，如果不存在，则直接插入，如果存在，则用新的value替换旧的value，在本题中，第一条put语句，会将key/value对插入HashMap，而第二条put，因为已经存在一个key为name的项，所以会用新的value替换旧的vaue，因此，两条put之后，HashMap中只有一个key/value键值对。那就是（name，jack）。所以，size为1.

### 49

意思就是存的顺序 与取出来的顺序完全相反
 Stack 栈 先进后出
 Queue 队列 先进先出
 List 集合 有下标 存的顺序与取得的顺序一致
 LinedList 类 是Queue的子类 存的顺序与取得的顺序一致

### 50Switch

switch...case的三个规则： 

  （1）既无成功匹配，又无default子句，那么swtich语句块什么也不做； 

  （2）无成功匹配，但有default，那么swtich语句块做default语句块的事； 

  （3）有成功匹配，没有break，那么成功匹配后，一直执行，直到遇到break。

### 51

外部类：只能有两种访问控制级别，public 和 默认。外部类没有处于任何类的内部，因此private和public访问控制符没有任何意义。 

  成员内部类：位于类内部但不包括位于块、构造器、方法内，且有名称的类，修饰符有public,private,protected访问控制符，也可以用static,final关键字修饰。 

  局部内部类：位于块、构造器、方法内的有名称类，最多只能有final修饰。

![image-20220918171248204](D:\HOLY\路线与笔记\markdown\面试\assets\image-20220918171248204.png)

### 52static

静态成员被所有对象共享

即如果某对象调用静态成员变量并修改了静态成员变量的值 那么所有的对象调用静态成员变量的值都将被修改

### 53精度

会产生信息丢失不如说**丢失精度**，这样可能更容易明白，而**精度丢失只会发生在从大范围到小范围的转换**

### 54

ArrayList 底层是基于动态数组，根据下表随机访问数组元素的效率高，向数组尾部添加元素的效率高；但是，删除数组中的数据以及向数组中间添加数据效率低。

  linkedList 增加和删除效率高 因为底层是用双向链表实现的。

### 55

- String：不可变，线程安全；
- StringBuffer：可变，线程安全；
- StringBuilder：可变，线程不安全；

  B.同时用 abstract和final就会自相矛盾。 

抽象类不能声明为 `final`, 被声明为 `final` 的类无法被继承，很明显不符合抽象类的定义

  C.Hashmap中的value可以之null，get(key)==null有两种情况，一是key不存在，二是该key中存的是null，所以应该使用map.containskey(key)返回的true/false来判断是否存在这个key。 

  D.volatile关键字有两个作用： 

  1.并发环境可见性：volatile修饰后的变量能够保证该变量在线程间的可见性，线程进行数据的读写操作时将绕开工作内存（CPU缓存）而直接跟主内存进行数据交互，即线程进行读操作时直接从主内存中读取，写操作时直接将修改后端变量刷新到主内存中，这样就能保证其他线程访问到的数据是最新数据 

  2.并发环境有序性：通过对volatile变量采取内存屏障（Memory barrier）的方式来防止编译重排序和CPU指令重排序，具体方式是通过在操作volatile变量的指令前后加入内存屏障，来实现happens-before关系，保证在多线程环境下的数据交互不会出现紊乱

### 55volatile

出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。

### 56标识符

**标识符：**

  **1. 只能由数字，字母，符号（有且仅有_和$两个）组成。**

  **2. 数字不能作为标识符的开头。**

  **3. 不能和关键字，保留字，显式常量一样。关键字都是小写的。**

  **4. null，true，false都不是关键字，属于显式常量。goto，const都是保留关键字。**

### 57类修饰符

普通类（外部类）：只能用public、default（不写）、abstract、final修饰。 

（成员）内部类：可理解为外部类的成员，所以修饰类成员的public、protected、default、private、static等关键字都能使用。 

局部内部类：出现在方法里的类，不能用上述关键词来修饰。 

匿名内部类：给的是直接实现，类名都没有，没有修饰符。

### 58构造方法

构造方法是一种特殊的方法，具有以下特点。    （1）构造方法的方法名必须与类名相同。    （2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。    （3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。     （4）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。    （5）构造方法可以重载，以参数的个数，类型，顺序。

### 59JAVA得变量声明方式可以避免程序在多线程竞争

- ```A
  A volatile
  ```

- ```
  B static volatile
  ```

A B选项，免程序在多线程竞争情况下读到不正确的值需要保证内存可见性，即当一个线程修改了volatile修饰的变量的值，volatile会保证新值立即同步到主内存，以及每次使用前立即从主内存读取。 

  C选项，synchronized可以修饰方法、代码块或对象，并不修饰变量。 

  D选项，static修饰的变量属于类，线程在使用这个属性的时候是从类中复制拷贝一份到线程工作内存中的，如果修改线程内存中的值之后再写回到原先的位置，就会有线程安全问题。用static修饰的变量可见性是无法确保的。

### 60封装

**1** **、什么是封装？**

**封装就是将属性私有化，提供公有的方法访问私有属性。------------------- 所以CD错误。**

做法就是：修改属性的可见性来限制对属性的访问，并为每个属性创建一对取值（ getter ）方法和赋值（ setter ）方法，用于对这些属性的访问。

如： private String name;

public String getName(){

​          return;

​      }

​    public void setName(String name){

​          this.name=name;

​      }

**2、**   **为什么需要封装？**

  **通过封装，可以实现对属性的数据访问限制，同时增加了程序的可维护性。**

  **由于取值方法和赋值方法隐藏了实现的变更，因此并不会影响读取或修改该属性的类，避免了大规模的修改，程序的可维护性增强**



### 61

关于String、StringBuffer、StringBuilder区别总结： 

  1.可变不可变 

  String用final修饰，所以string对象是不可变的 

  StringBuffer和StringBuilder都是继承AbstratStringBuilder，在AbstratStringBuilder中是使用字符串数组保存字符串，由此可知这两种对象是可变的 

  2.线程安全 

  String对象是不可变的，可以理解为常量，所以是线程安全的 

  StringBuffer对方法加了同步锁或者对被调用的方法加了同步锁，所以是线程安全的 

  StringBuilder没有对方法加同步锁，所以是非线程安全的 

  3.效率 

  String<StringBuffer<StringBuilder 

### 62



1.Statement、PreparedStatement和CallableStatement都是接口(interface)。 

2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。 
\3. 
Statement接口提供了执行语句和获取结果的基本方法； 
PreparedStatement接口添加了处理 IN 参数的方法； 
CallableStatement接口添加了处理 OUT 参数的方法。 
\4. 
a.Statement: 
普通的不带参的查询SQL；支持批量更新,批量删除; 
b.PreparedStatement: 
可变参数的SQL,编译一次,执行多次,效率高; 
安全性好，有效防止Sql注入等问题; 
支持批量更新,批量删除; 
c.CallableStatement: 
继承自PreparedStatement,支持带参数的SQL操作; 
支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持; 

Statement每次执行sql语句，数据库都要执行sql语句的编译 ， 
最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。 

PreparedStatement是预编译的，使用PreparedStatement有几个好处 
\1. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。 
\2. 安全性好，有效防止Sql注入等问题。 
\3. 对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch； 
\4. 代码的可读性和可维护性。

### 63

![image-20220921092707215](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220921092707215.png)

A选项，静态内部类继承ReentrantLock可重入锁来管理锁，没有用synchronized



```
static` `class` `Segment<K,V> ``extends` `ReentrantLock ``implements` `Serializable {``    ``private` `static` `final` `long` `serialVersionUID = 2249069246763182397L;``    ``final` `float` `loadFactor;``    ``Segment(``float` `lf) { ``this``.loadFactor = lf; }``  ``}
```

B选项，应该是实现了Map接口



```
public` `class` `HashMap<K,V> ``extends` `AbstractMap<K,V>``  ``implements` `Map<K,V>, Cloneable, Serializable
```

C选项，查看源码可以看出返回的是Arrays的私有内部类
而不是ArrayList对象



```
// Arrays.java``private` `static` `class` `ArrayList ``extends` `AbstractList``    ``implements` `RandomAccess, java.io.Serializable``  ``{``    ``private` `static` `final` `long` `serialVersionUID = -2764017481108945198L;``    ``private` `final` `E[] a;``    ``ArrayList(E[] array) {``      ``a = Objects.requireNonNull(array);``    ``}
```

D选项，的确线程不安全，文档上是这么写的

```
日期格式不同步。 建议为每个线程创建单独的格式实例。 ``如果多个线程同时访问格式，则必须在外部进行同步。
```

### 64父类引用指向子类

![image-20220921093148652](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220921093148652.png)

![image-20220921093207813](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220921093207813.png)

也就是是编译的时候会把它当成左边的类型，运行的时候看右边类型的方法体。这个题动物类没有另一个方法，而b调用了，所以编译器会认为b是一个动物类，所以报错。这就是多态的特性吧

### 65重载与重写要求

方法的重载要求：（方法名必须一样， 方法签名必须不同）

  方法名必须一样

  参数表必须不同（数目或者类型不同）

  返回类型、修饰符可以相同也可以不同。

   

方法的重写：         方法的签名必须一样（方法名必须一样，参数保持一致）并且返回类型、访问权限、抛出的异常都有限制

​            返回类型小于等于父类的返回类型

​            子类抛出的异常小于等于父类方法抛出的异常

​            子类方法的访问权限不得小于父类方法的访问权限

### 66 **=**与equal

#### 1.== 和 equals():

(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。

(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。

  2.String对象的两种创建方式:

(1)第一种方式: String str1 = "aaa"; 是在常量池中获取对象("aaa" 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)

(2)第二种方式: String str2 = new String("aaa") ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 "aaa" 象）。

​    System.out.println(str1==str2);//false



#### 3.String类型的常量池比较特殊。它的主要使用方法有两种：

(1)直接使用双引号声明出来的String对象会直接存储在常量池中。
(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。
  String s1 = new String("AAA");
  String s2 = s1.intern();
  String s3 = "AAA";
  System.out.println(s2);//AAA
  System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，

  System.out.println(s2 == s3);//true， s1,s2指向常量池中的”AAA“

#### 4字符串拼接：

  String a = "a";
  String b = "b";
    
  String str1 = "a" + "b";//常量池中的对象
  String str2 = a + b; //在堆上创建的新的对象  
  String str3 = "ab";//常量池中的对象
  System.out.println(str1 == str2);//false
System.out.println(str1 == str3);//true 
  System.out.println(str2 == str3);//false

### 67值传递与引用传递

1、按值传递（传递数值）
 2、按引用传递（传递对象的引用，即数据的地址）

 一、按值传递 call by value
 1、不会改变传递的数值大小

 二、按引用传递 call by reference
 1、不会改变传递的数据的地址
 2、可以改变传递的数据参数内容



### 68



```
public` `static` `String toString(``char` `c) {``  ``return` `String.valueOf(c);``}
```



```
public` `static` `String valueOf(``char` `c) {``  ``char` `data[] = {c};``  ``return` `new` `String(data, ``true``);``}
```

 返回的结果是一样的

只有char变int才会变数字

### 69

final修饰的变量，变量的引用（地址）是不可变得，但是引用的内容是可变的

### 70

链接：https://www.nowcoder.com/questionTerminal/5dbdf7b89d9a4c27908a8c5c1e88c2fe
来源：牛客网



- 静态方法（static修饰）是静态绑定，编译期间根据创建对象时，等号左边的数据类型确定调用父类还是子类的方法。因此不会调用子类Sub的`getType`方法，只会调用父类Super的。    
-    重载是静态绑定，编译时多态，编译期间根据实参的等号左边的数据类型去严格匹配形参的数据类型和个数。   

[复制代码](#)

```
public` `class` `StaticInherit {``  ``public` `static` `void` `main(String[] args) {``    ``Collection<?>[] collections =``        ``{``new` `HashSet<String>(), ``new` `ArrayList<String>(), ``new` `HashMap<String, String>().values()};``    ``System.out.println(``"静态绑定，看编译类型(左边)"``);` `    ``System.out.println(``"----------> 通过对象调用方法 <--------------"``);``    ``System.out.println(``"左边为父类，调用父类"``);``    ``Super subToSuper = ``new` `Sub();``    ``for``(Collection<?> collection: collections) {``      ``System.out.println(subToSuper.getType(collection));``    ``}` `    ``System.out.println(``"-------------------------"``);``    ``System.out.println(``"左边为子类，调用子类"``);``    ``Sub sub = ``new` `Sub();``    ``for``(Collection<?> collection: collections){``      ``System.out.println(sub.getType(collection));``    ``}` `    ``System.out.println(``"----------> 通过类调用方法 <--------------"``);``    ``System.out.println(``"Super调用方法"``);``    ``for``(Collection<?> collection: collections){``      ``System.out.println(Super.getType(collection));``    ``}``    ``System.out.println(``"---------------------"``);``    ``System.out.println(``"Sub调用方法"``);``    ``for``(Collection<?> collection: collections){``      ``System.out.println(Sub.getType(collection));``    ``}` `    ``System.out.println(``"------------> 通过对象调用属性 <-------------"``);``    ``System.out.println(subToSuper.name);``    ``System.out.println(sub.name);``    ``System.out.println(``"------------> 通过类调用属性 <-------------"``);``    ``System.out.println(Super.name);``    ``System.out.println(Sub.name);``  ``}` `  ``abstract` `static` `class` `Super {``    ``static` `String name = ``"Super"``;` `    ``public` `static` `String getType(Collection<?> collection) {``      ``return` `"Super:collection"``;``    ``}``    ``public` `static` `String getType(List<?> list) {``      ``return` `"Super:list"``;``    ``}``    ``public` `String getType(ArrayList<?> list) {``      ``return` `"Super:arrayList"``;``    ``}``    ``public` `static` `String getType(Set<?> set) {``      ``return` `"Super:set"``;``    ``}``    ``public` `String getType(HashSet<?> set) {``      ``return` `"Super:hashSet"``;``    ``}``  ``}` `  ``static` `class` `Sub ``extends` `Super {``    ``static` `String name = ``"Sub"``;` `    ``public` `static` `String getType(Collection<?> collection) {``      ``return` `"Sub"``; }``  ``}``}
```

-    输出结果   

[复制代码](#)

```
静态绑定，看编译类型(左边)``----------> 通过对象调用方法 <--------------``左边为父类，调用父类``Super:collection``Super:collection``Super:collection``-------------------------``左边为子类，调用子类``Sub``Sub``Sub``----------> 通过类调用方法 <--------------``Super调用方法``Super:collection``Super:collection``Super:collection``---------------------``Sub调用方法``Sub``Sub``Sub``------------> 通过对象调用属性 <-------------``Super``Sub``------------> 通过类调用属性 <-------------``Super``Sub
```

### 71java中的集合类型

![img](https://uploadfiles.nowcoder.com/images/20190626/8063197_1561528276822_5E395ABADA193BD98F733540EDD03F5C)

### 72



以下哪些表达式返回为真（）  

```
String a=``"My field1"``;``String b=``"My field1"``;``  ``String c=``new` `String(``"My field1"``);``  ``String d=``new` `String(``"My field1"``);
```

![img](https://uploadfiles.nowcoder.com/images/20220705/920575805_1657016009014/CAE614F3E9571B3551A403845E282016)



==，如果作用的是基本数据类型，则比较的是存储的值是否相同，如果作用引用的数据类型，则比较的是存储的值和对象的地址是否相同； 

  equals只作用于引用型的数据类型，equals方法是用来比较两个对象的引用是否相等

### 73

A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。
 B，CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。
 C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。
 D，Counter不是并发编程的同步器

### 74

（1）基本类型，比如int，double，char都是值传递 

  例： 

  void change(int a) 

  {a++;}                 

​    public static void main(String[] args)  

​    {  

​     int i=1;


​     change(i);


​    }  

   change执行之后i为1，为什么呢？因为执行change(i)时复制了一份i(pie)，然后把复制的i(pie)撇传进去了，这就是值传递，没有影响到原来的i本身。  

   **这里注意，String为值传递，具体原因：记住就行，经常有人用这个考你。**


   （2）对象类型:比如一个pojo，或者是数组对象  

   例：  

  class User 

  { 

​    public int id;


   }


  void change(User user) 

  { 

​    user.id++;


  } 

   public static void main(String[] args)  

​    {  

​      User user = new User();


​     user.id=1;


​     change(user);  

​    }  

   change执行后的user.id不是之前的1而变成了2，为什么呢？因为执行change(user)时是引用传递，直接将user本身的地址传了进去，实际参数都会发生变化。  

   **数组和对象一样，也是引用传递，具体原因：记住就行，经常有人用这个考你。**  

   这个问题引申出来就会出现对象的复制问题

   User a = new User();  

   User b = a;  

   不是新建一个和a一样的User b，而是b和a一起引用User a这个对象

### 75 

instance of 用来判断该对象是否是一个类的实例，一个子类的实例，一个接口的实现类

### 76

synchrozied关键字称作同步，主要用来给方法、代码块加锁，被加锁的代码段，同一时间内多线程同时访问同一对象的加锁方法/代码块时，只能有一个线程执行能执行方法/代码块中的代码，其余线程必须等待当前线程执行完以后才执行该方法/代码块。

volatile关键字1.保证了不同线程对该变量操作的内存可见性.(当一个线程修改了变量,其他使用次变量的线程可以立即知道这一修改)。2.禁止了指令重排序.

Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。

transient关键字 简单地说，就是让某些被修饰的成员属性变量不被序列化。

### 77

接口体现的是一种规范和实现分离的设计哲学，代码编写过程中充分利用接口可以很大程度的降低程序各个模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这一原则，很多软件架构更提倡面向接口编程而不是实现类编程。

接口和抽象类都可以被声明使用

类到底能不能被实例化是初学者很容易犯的错误，抽象类确实有构造方法，但这个构造方法是用来被子类调用的，因为任何子类都必须调用从Object开始的所有父亲的构造方法，才算完成初始化工作。如果抽象类被实例化，就会报错，编译无法通过。而接口里不包含构造器，自然无法被实例化。

### 78

记住接口中的方法都是public abstract类型的，变量都是public static final类型的，既然方法字段都是public类型的，就是为了让所有的类、包使用的，所以自然需要使用public去修饰了。

### 79

后端获取数据，向前端输出的过程中，输出前应该采用信息安全部发布的XSSFilter进行相应编码。

### 80

Java 的屏幕坐标是以像素为单位，容器的左上角被确定为坐标的起点 是左上角，不是左下角

### 81

方法区和堆内存是线程共享的。 程序计数器、虚拟机栈是线程隔离的。

### 82

Socket套接字，就是源端口号和目标端口号的组合 

  服务器端：ServerSocket提供的实例 

   ServerSocket server = new ServerSocket(端口号) 

  客户端，Socket提供的实例 

  Socket soc = new Socket(ip地址，端口号)

### 83

首先分为异常和错误： 

​      错误不用处理，因为也没法处理 

​      异常：分为运行时异常、非运行时异常 

​          运行时异常自己选择是否要 try catch ,也可以自己 throw 

​          非运行时异常就必须得try catch 或者 throws 

### 84执行顺序

初始化静态变量--执行静态代码块--执行main方法

public class Test1 {

    static int cnt = 6;
    
    static {
        cnt += 9;
    }
    
    public static void main(String[] args) {
        System.out.println("cnt =" + cnt);
    }
    
    static {
        cnt /= 3;
    }
    }
\1. static int cnt = 6; 父类静态变量

\2. cnt += 9; （cnt＝15），父类静态代码块1

\3. cnt /=3;（cnt＝5），父类静态代码块2



### 85

**Applet** 是一种在 Web 环境下，运行于客户端的Java程序组件。Applet 必须运行于某个特定的“容器”，这个容器可以是浏览器本身，也可以是通过各种插件，或者包括支持 Applet 的移动设备在内的其他各种程序来运行。与一般的Java应用程序不同，Applet 不是通过 main 方法来运行的。**Applet运行之前，先调用 Init() 方法，然后调用 start() 方法，最后调用 paint() 方法。**

### 86

如果将父类放在前面的话，异常将被父类完全捕获，子类永远不能捕获异常

简单记忆：老将（牛X的）都是最后出马

（ 若 catch 中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面 ）

### 87

**以下** **b** **的值是：** **byte b = (byte)129;**

这题考察的就两个知识点：一、强制转换（主要涉及各个类型占几个字节，这里我只简单说一下byte型占一个字节，也就是8位，int型4个字节，32位）；二、在计算机系统中，数值一律用**补码**来表示（存储）

正数：补码=反码=原码（当然以二进制形式表达）

129 int类型（4个字节）二进制： 00000000 00000000 00000000 10000001

强制转换byte型后，只有一个字节即 10000001（注意这里从二进制角度看，第一位是符号位，即求负数的补码接下来）

只要求出上面原码对应的补码就行了，然后再转换对应的int型数值（因为题干所给的答案都是比较int型）

10000001（原码） 对应的反码为1111 1110

又补码等于反码+1

即1111 1111 该二进制转换int型刚好是-127（1+2+4+8+16+32+64）

普及一下：正数原码，反码，补码相同

负数反码除了符号位不变，其他位取反，补码=反码+1；

### 88 Arraylist扩容

![image-20220925105348248](D:\HOLY\Pate&Notes\markdown\面试\assets\image-20220925105348248.png)
